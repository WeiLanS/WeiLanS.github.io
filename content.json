{"meta":{"title":"HelloJohn","subtitle":"It’s been a long time.","description":null,"author":"Hello John","url":"https://weilans.github.io","root":"/"},"pages":[{"title":"[404]","date":"2019-07-21T14:56:15.913Z","updated":"2019-07-21T14:54:11.884Z","comments":true,"path":"404.html","permalink":"https://weilans.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-07-21T14:46:30.967Z","updated":"2019-07-21T14:46:30.967Z","comments":true,"path":"about/index.html","permalink":"https://weilans.github.io/about/index.html","excerpt":"","text":"你要忍，忍到春暖花开； 你要走，走到灯火通明； 你要看过世界辽阔，再评判是好是坏； 你要卯足劲变好，再旗鼓相当站在不敢想象的人身边； 你要变成想象中的样子，这件事，一步都不能让。"}],"posts":[{"title":"[Java并发札记] 2.Java并发编程基础","slug":"Java并发札记-2-Java并发编程基础","date":"2019-08-24T16:01:46.000Z","updated":"2019-08-27T16:15:11.136Z","comments":true,"path":"2019/08/25/Java并发札记-2-Java并发编程基础/","link":"","permalink":"https://weilans.github.io/2019/08/25/Java并发札记-2-Java并发编程基础/","excerpt":"","text":"并发概念同步（Synchronous） 异步（Asynchronous） 同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中“真实”地执行。整个过程，不会阻碍调用者的工作。如果异步调用需要返回结果，那么当这个异步调用真实完成时，则会通知调用者。 阻塞（Blocking） 非阻塞（NonBlocking） 阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） 死锁、饥饿和活锁都属于多线程的活跃性问题。 饥饿：指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源。或者某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行。 活锁：主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。 死锁：资源竞争而产生的相互等待的情况。主要原因是资源有限以及竞争不当。四个必要条件：互斥、占有且等待、不可抢占、循环等待（存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源）。避免死锁可以使用银行家算法。 并发（Concurrency）和并行（Parallelism） 严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会儿运行任务A一会儿执行任务B，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。 Java 并发编程基础线程线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。 线程的状态见于 Thread.State 枚举类： 初始(NEW) - 新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE) - Java线程中将就绪(ready)和运行中(running)两种状态笼统的成为“运行中”。（等待被线程调度选中获取cpu的使用权，处于就绪状态(ready)；就绪的线程在获得cpu 时间片后变为运行中状态(running)）。 阻塞(BLOCKED) - 表示线程阻塞于锁。 等待(WAITING) - 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIME_WAITING) - 该状态不同于WAITING，它可以在指定的时间内自行返回。 终止(TERMINATED) - 表示该线程已经执行完毕。 构造线程新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的 ContextClassLoader 以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。 虽然可以使用匿名内部类重载run()方法来新建一个线程。但考虑到Java是单继承的，也就是说继承本身也是一种很宝贵的资源，因此，主要使用Runnable接口来实现同样的操作。 终止线程stop()方法太过于暴力，强行把执行到一半的线程终止，并不会保证线程资源的正常释放，通常没有给予线程完成资源释放工作的机会，可能会引起一些数据不一致的问题，导致程序可能工作在不确定状态下。 suspend(), resume(), stop()都标注为过期方法，暂停以及恢复操作可以使用等待/通知机制代替。suspend()方法在导致线程暂停的同时，并不会去释放任何锁资源，任何线程想要访问锁都会被牵连，导致无法正常继续运行。 中断线程中断可以理解为是线程的一个标志位属性。线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出。至于目标线程接到通知后如何处理，则完全由目标线程自行决定。 123456// 中断线程public void Thread.interrupt() // 判断是否被中断public boolean Thread.isInterrupted() // 判断是否被中断，并清除当前中断状态public static boolean Thread.interrupted() 许多声名抛出InterruptedException的方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。 123456789101112131415161718192021222324public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; while (true) &#123; if (Thread.currentThread().isInterrupted()) &#123; System.out.println(\"Interruted!\"); break; &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; System.out.println(\"Interruted When Sleep\"); //设置中断状态 Thread.currentThread().interrupt(); &#125; Thread.yield(); &#125; &#125; &#125;; t1.start(); Thread.sleep(2000); t1.interrupt();&#125; 如果线程被中断程序会抛出异常，进入catch子句，为了后续逻辑处理，执行了Thread.interrupt()方法再次中断自己，置上中断标记位。只有这么做，在中断检查中，才能发现当前线程已经被中断了。 安全地终止线程：中断操作是一种简单的线程间交互方式，此种交互方式最适合用来取消或停止任务。除了中断之外，还可以利用一个boolean变量控制是否需要停止任务并终止该线程。示例代码中可以通过标识位或者中断的方式使线程在终止时有机会去清理资源。 123456789101112131415161718192021222324252627282930313233public class Shutdown &#123; public static void main(String[] args) throws Exception &#123; Runner one = new Runner(); Thread countThread = new Thread(one, \"CountThread\"); countThread.start(); // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束 TimeUnit.SECONDS.sleep(1); countThread.interrupt(); Runner two = new Runner(); countThread = new Thread(two, \"CountThread\"); countThread.start(); // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束 TimeUnit.SECONDS.sleep(1); two.cancel(); &#125; private static class Runner implements Runnable &#123; private long i; private volatile boolean on = true; @Override public void run() &#123; while (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; i++; &#125; System.out.println(\"Count i = \" + i); &#125; public void cancel() &#123; on = false; &#125; &#125;&#125; 线程组ThreadGroup不属于Java并发包中的内容，它是java.lang中的内容。主要用于对线程方便进行统一管理，线程组可以进行复制，快速定位到一个线程，统一进行异常设置等。 activeCount()可以获得活动线程的总数，但由于线程是动态的，因此这个值只是一个估计值，无法确定精确，list()方法可以打印这个线程组中所有的线程信息，对调试有一定帮助。 ThreadGroup中有一个uncaughtException()方法。当线程组中某个线程发生Unchecked exception异常时，由执行环境调用此方法进行相关处理，如果有必要，可以重新定义此方法。 123456789101112131415161718192021public static void main(String[] args) &#123; ThreadGroup threadGroup1 = // 匿名类写法 new ThreadGroup(\"group1\") &#123; // 继承ThreadGroup并重新定义以下方法 // 在线程成员抛出unchecked exception 会执行此方法 public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(t.getName() + \": \" + e.getMessage()); &#125; &#125;; // 匿名类写法 Thread thread1 = // 这个线程是threadGroup1的一员 new Thread(threadGroup1, new Runnable() &#123; public void run() &#123; // 抛出unchecked异常 throw new RuntimeException(\"测试异常\"); &#125; &#125;); thread1.start();&#125; 守护线程Daemon线程：是一种支持型线程，主要用作程序后台调度以及支持性工作。当一个Java虚拟机中不存在非Daemon线程的守护，Java虚拟机会退出。可以通过在启动之前设置Thread.setDaemon(true)来设置。 构建Daemon线程时，不能依靠构建finally块中的内容来确保执行关闭或清理资源的逻辑。 12345678910111213141516171819202122public class DaemonDemo &#123; public static class DaemonT extends Thread &#123; @Override public void run() &#123; while (true) &#123; System.out.println(\"I am alive\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t = new DaemonT(); t.setDaemon(true); t.start(); Thread.sleep(3000); // 在main线程休眠3秒后退出时，整个程序会随之结束 &#125;&#125; 线程优先级123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 优先级的范围是1~10，默认优先级是5。 线程的优先级调度和底层操作系统有密切的关系，在各个平台上表现不一，并且这种优先级产生的后果也可能不容易预测，无法精准控制，操作系统可能完全不会理会Java线程对优先级的设定。 synchronized原理同步代码块的实现会使用 monitorenter 和 monitorexit 指令，同步方法则依靠方法修饰符上的 ACC_SYNCHRONIZED 来完成的。无论是何种方式，本质上是对一个对象的监视器 (moitor) 进行获取，任何对象都有一个monitor与之关联，这个过程是排他的，每个对象都拥有自己的监视器，同一时刻只能一个线程获得对象监视器。 monitorenter 指令是在编译后插入到同步代码块的开始位置，monitorexit 是插入到方法结束处和异常处（JVM保证了每个monitorenter 有对应的 monitorexit 与之配对）。当执行 monitorenter 指令时，执行线程必须先获取到该对象的监视器才能进入，没有获取到监视器的线程会阻塞在同步块或同步方法的入口处没进入 BLOCKED 状态。 执行 monitorenter 时获取对象的锁，会把锁的计数器+1（可重入），在执行 monitorexit 时锁计数器会－1，当计数器为0会释放锁。 synchronized 用的锁是存在Java对象头里的，加锁本质就是在锁对象的对象头中写入当前线程id。 案例 当修饰静态方法的时候，锁定的是当前类的 Class 对象； 当修饰非静态方法的时候，锁定的是当前实例对象 this。 case1123456789class SafeCalc &#123; long value = 0L; long get() &#123; return value; &#125; synchronized void addOne() &#123; value += 1; &#125;&#125; 执行 addOne()方法后，value值对于get()方法是没有可见性保证的，需要在 get 方法上也加上 synchronized。 case2123456789class SafeCalc &#123; static long value = 0L; synchronized long get() &#123; return value; &#125; synchronized static void addOne() &#123; value += 1; &#125;&#125; 上面的代码是用两个锁保护一个资源。这个受保护的资源就是静态变量 value，两个锁分别是 this 和 SafeCalc.class。由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。 case3123456pulbic class Something &#123; public synchronized void isSyncA()&#123;&#125; public synchronized void isSyncB()&#123;&#125; public static synchronized void cSyncA()&#123;&#125; public static synchronized void cSyncB()&#123;&#125;&#125; x.isSyncA()与x.isSyncB() 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁； x.isSyncA()与y.isSyncA() 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁； x.cSyncA()与y.cSyncB() 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问； x.isSyncA()与Something.cSyncA()可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。 死锁转账案例12345678910class Account &#123; private int balance; // 转账 synchronized void transfer(Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; 上述代码用于多Account转账是不正确的，因为 synchronized 使用的是 this 这把锁可以保护自己的余额 this.balance，但是保护不了别人的余额 target.balance。 所以可以使用 Account.class作为共享的锁。但会将所有Account的操作串行，性能会很差。 123456789101112class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; synchronized(Account.class) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; 于是可以采用如下方式，使用两把锁： 12345678910111213141516class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 锁定转出账户 synchronized(this) &#123; // 锁定转入账户 synchronized(target) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125; 但这样就会造成死锁，A要向B转账，B也要向A转账，同时拿到第一个锁，但无法等到第二个锁。 死锁发生条件 互斥，共享资源 X 和 Y 只能被一个线程占用； 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X； 不可抢占，其他线程不能强行抢占线程 T1 占有的资源； 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。 避免死锁只要破坏上述其中一个条件，死锁就不会发生。互斥条件无法破坏，其他三种有方法破坏： 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。 关于1，可以添加一个账本管理员，必须通过账本管理员拿到所有资源才会提供给相关方，通过这种方案保证一次申请所有资源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Allocator &#123; private List&lt;Object&gt; als = new ArrayList&lt;&gt;(); // 一次性申请所有资源 synchronized boolean apply(Object from, Object to)&#123; if (als.contains(from) || als.contains(to))&#123; return false; &#125; else &#123; als.add(from); als.add(to); &#125; return true; &#125; // 归还资源 synchronized void free(Object from, Object to)&#123; als.remove(from); als.remove(to); &#125;&#125;class Account &#123; // actr 应该为单例 private Allocator actr; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 while(!actr.apply(this, target)) ； try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; actr.free(this, target) &#125; &#125; &#125; 关于2，可以使用Lock。 关于3，可以对每个账号ID进行排序，按照从小到大的顺序锁账号，这样便不会出现循环等待的情况了。破坏循环等待条件的成本在这种场景下是最低的。 1234567891011121314151617181920212223class Account &#123; private int id; private int balance; // 转账 void transfer(Account target, int amt)&#123; Account left = this; Account right = target; if (this.id &gt; target.id) &#123; left = target; right = this; &#125; // 锁定序号小的账户 synchronized(left)&#123; // 锁定序号大的账户 synchronized(right)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125; 如果Account对象中只有转账业务的话，while(actr.apply(this, target) 和 synchronized(Account.class)的性能优势几乎看不出来，synchronized(Account.class)方案由于 synchronized 三次，性能可能更差；但是如果Account对象中如果还有其它业务，比如查看余额等功能也加了synchronized(Account.class)修饰，那还是while的方式效率更高。此外，如果转账操作非常慢，也是while更有优势。 等待 / 通知 机制线程A调用对象O的wait方法进入等待状态，线程B调用对象O的notify或notifyAll方法后，线程A收到通知后从对象O的wait方法返回，进而执行后续操作。 典型范式等待方（加锁，循环，处理逻辑）1）获取对象的锁。2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。3）条件满足则执行对应的逻辑。 123456 synchronized(对象) &#123; while(条件不满足时) &#123; 对象.wait() &#125; 对应的逻辑&#125; 之所以使用while loop，因为可能有其他线程执行对象的notify()或notify()方法，但是条件不满足。即“条件曾经满足过”。当 wait() 返回时，有可能条件已经发生变化了，曾经条件满足，但是现在已经不满足了，所以要重新检验条件是否满足。范式，意味着是经典做法，所以没有特殊理由不要尝试换个写法。 通知方1）获得对象的锁。2）改变条件。3）通知所有等待在对象上的线程。 1234synchronized(对象) &#123; 改变条件 对象.notifyAll()&#125; 如何工作 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。 notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。 注意点： 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。 notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。 wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；如果 synchronized 锁定的是 其他target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException。 典型描述： WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。 案例改写将前文中提到的转账例子可以改写为： 123456789101112131415161718192021class Allocator &#123; private List&lt;Object&gt; als; // 一次性申请所有资源 synchronized void apply(Object from, Object to)&#123; // 经典写法 while(als.contains(from) || als.contains(to))&#123; try&#123; wait(); &#125;catch(Exception e)&#123; &#125; &#125; als.add(from); als.add(to); &#125; // 归还资源 synchronized void free(Object from, Object to)&#123; als.remove(from); als.remove(to); notifyAll(); &#125;&#125; 同时需尽量使用notifyAll()方法，notify()会随机通知一个等待队列中的一个线程，notifyAll()会通知等待队列中的所有线程。 依然基于上面的例子，假设线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列，线程 4 申请 CD 也会进入等待队列。假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。 join一个线程A执行了thread.join()时代表当前线程A等待线程终止后才从thread.join()返回。 12public final void join() throws InterruptedExceptionpublic final synchronized void join(long millis) throws InterruptedException 第一个join()方法表示无限等待，它会一直阻塞当前线程，直到目标线程执行完毕。第二个方法给出了一个最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因为“等不及了”，而继续往下执行。 其方法内部使用等待/通知机制，不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。当join线程终止时，会调用线程自身的notifyAll()方法，通知所有等待在该线程上的线程。 1234567public final synchronized void join(long millis) throws InterruptedException &#123; // 条件不满足，继续等待 while (isAlive()) &#123; wait(0); &#125; // 条件满足，方法返回&#125; 上述代码和等待 / 通知经典范式一致，即加锁、循环、处理逻辑三个步骤。 值得注意的一点是：不要在应用程序中，在Thread对象实例上使用类似wait()或者notify()等方法，因为这很有可能会影响系统API的工作，或者被系统API所影响。 yield1public static native void yield(); Thread.yield()是一个静态方法，一旦执行，它会使当前线程让出CPU。但要注意，让出CPU并不表示当前线程不执行了。当前线程在让出CPU后，还会进行CPU资源的争夺，但是是否能够再次被分配到，就不一定了。因此，对Thread.yield()的调用就好像是在说：我已经完成一些最重要的工作了，我应该是可以休息一下了，可以给其他线程一些工作机会。 如果一个线程不那么重要，或者优先级非常低，而且又害怕它会占用太多的CPU资源，那么可以在适当的时候调用Thread.yield()，给予其他重要线程更多的工作机会。 Case下面代码会得到小20000000很多的数值，原因是Integer属于不变对象。也就是对象一旦被创建，就不可能被修改。 i++ 在真实执行时变成了 i=Integer.valueOf(i.intValue()+1); i++ 的本质是，创建一个新的Integer对象，并将它的引用赋值给i。锁加到不同的对象实例上了。 123456789101112131415161718192021public class BadLockOnInteger implements Runnable &#123; public static Integer i = 0; static BadLockOnInteger instance = new BadLockOnInteger(); @Override public void run() &#123; for (int j = 0; j &lt; 10000000; j++) &#123; synchronized (i) &#123; i++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125;&#125; Reference《实战Java高并发程序设计》 《Java并发编程的艺术》 https://time.geekbang.org/column/article/84601","categories":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/categories/concurrent/"}],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/tags/concurrent/"}]},{"title":"[Java并发札记] 1. Java内存模型","slug":"Java并发札记-1-Java内存模型","date":"2019-08-24T16:01:46.000Z","updated":"2019-08-27T01:25:33.245Z","comments":true,"path":"2019/08/25/Java并发札记-1-Java内存模型/","link":"","permalink":"https://weilans.github.io/2019/08/25/Java并发札记-1-Java内存模型/","excerpt":"","text":"Java内存模型JMM控制线程间的通信，定义了工作内存和主内存的抽象关系，每个线程有私有工作内存，保留该线程使用的变量的主内存副本拷贝，读写都在工作内存中进行。若要通信的话需把本地内存刷新到主内存中，另一个线程从主内存中读取。 模型三种特征JMM的关键点都是围绕着多线程的原子性、可见性和有序性来建立的。（即为JMM如何解决前篇文中提到的并发问题） 原子性基本数据类型的访问读写是具备原子性的（例外32位系统中long和double的读写是非原子性）。若应用场景需要更大规模的原子性保证，JVM提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 可见性指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile可以保证可见性。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。Java中的synchronized和final两个关键字也可以实现可见性。 synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。 synchronized 的可见性也可以通过 Happens-Before 推断：“对一个锁解锁 Happens-Before 后续对这个锁的加锁”，指的是前一个线程的解锁操作对后一个线程的加锁操作可见，综合 Happens-Before 的传递性原则，我们能得出前一个线程在临界区修改的共享变量（该操作在解锁之前），对后续进入临界区（该操作在加锁之后）的线程是可见的。 final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把”this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。 有序性程序在执行时，可能会进行指令重排序，重排后的指令与原指令的顺序未必一致。 重排序在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（ ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 如果在单线程内观察，所有的操作都是有序的，这就是“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。而重排序对多线程则会有影响，重排序只保证单线程串行语义一直，没有义务保证多线程的语义也一致。 在Java中，可以使用volatile和synchronized来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。 as-if-serial语义不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。as-if-serial语义把单线程程序保护了起来。 指令重排也是有原则的，并非所有指令都可以随意重排，Happens-before 可以指定两个操作之间的顺序。Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：前面一个操作的结果对后续操作是可见的。 Happens-Before 原则下面的这些原则是指令重排不可违背的： 程序顺序原则：在一个线程中，前面的操作 Happens-Before 于后面任何操作。 管程锁定规则：对一个锁的解锁 Happens-Before于后续对这个锁的加锁。 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。 volatile变量规则：对一个volatile变量的写操作 Happens-Before 于后面对这个变量的读操作。 线程启动规则：Thread对象的start()方法 Happens-Before 于此线程的每一个动作。 线程终止规则：线程中所有操作都 Happens-Before 于此线程的终结。 对象终结规则：对象的构造函数执行结束 Happens-Before 于finalize方法。 这些先行发生关系无须使用任何同步手段就能成立，可以在编码中直接使用，这是Java内存模型对程序员的保证。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 123456789101112131415161718192021222324//////////程序启动规则示例/////////Thread B = new Thread(()-&gt;&#123; // 主线程调用 B.start() 之前 // 所有对共享变量的修改，此处皆可见 // 此例中，var==77&#125;);// 此处对共享变量 var 修改var = 77;// 主线程启动子线程B.start();//////////线程终止规则示例/////////Thread B = new Thread(()-&gt;&#123; // 此处对共享变量 var 修改 var = 66;&#125;);// 例如此处对共享变量修改，// 则这个修改结果对线程 B 可见// 主线程启动子线程B.start();B.join()// 子线程所有对共享变量的修改// 在主线程调用 B.join() 之后皆可见// 此例中，var==66 volatile使用volatile关键字修饰的变量，保证了其在多线程之间的可见 性，即当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得到的： 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存（写语义）； 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量（读语义）。 使用volatile的主要原因是其另一个特性：禁止指令重排序优化。比如说执行完某个操作时将布尔值设定为true，若没有volatile则会存在重排序的可能，设为true的操作会提前执行。编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。 “基于volatile变量的运算在并发下是安全的”不准确。20个线程，对volatile修饰的变量进行10000次自增，结果会小于200000。自增操作在加一时，变量值可能已经过期了。Volatile++ 此种复合操作无法保证原子性。 CaseQ: java 单例模式中双重检查锁定 volatile 的作用 1234567891011121314public class Singleton &#123; private Singleton() &#123;&#125; private volatile static Singleton instance; public Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; instance = new Singleton(); 包含了三个操作：1.分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。但由于存在重排序的问题，2和3可能进行重排序。用volatile修饰的话就可以禁止2和3操作重排序，从而避免这种情况。 那volatile是否起到了可见性的作用？否，第二次非null判断是在加锁以后，可见性已经由synchronized来保证了。 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。 Referencehttps://time.geekbang.org/column/article/84017 《Java并发编程的艺术》 《深入理解Java虚拟机》","categories":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/categories/concurrent/"}],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/tags/concurrent/"}]},{"title":"[Java并发札记] 0.并发问题的根源","slug":"Java并发札记-0-并发问题的根源","date":"2019-08-24T08:46:48.000Z","updated":"2019-08-24T14:28:53.592Z","comments":true,"path":"2019/08/24/Java并发札记-0-并发问题的根源/","link":"","permalink":"https://weilans.github.io/2019/08/24/Java并发札记-0-并发问题的根源/","excerpt":"","text":"正式开启并发的回顾整理，札记主要记录知识点、典型Case、自己的想法、思维导图以及好的文章，侧重于知识的理解与整理，毕竟要在并发上有自己独到的理解还是欠火候的。以后回顾或学习到新内容，会不断对文章进行更新，以作长期知识储备。 并发编程问题的根源1. CPU缓存导致“可见性”问题单核时代，所有线程操作同一个CPU的缓存，CPU缓存和内存间不会存在数据不一致问题。 一个线程对共享变量的修改，另一个线程能立刻看到，即为“可见性”。 多核时代，每个CPU都有自己的缓存，这就容易造成数据一致性问题。例如对应特定变量V，线程A操作CPU1上V的缓存，线程B操作CPU2上V的缓存，前者对V的操作于后者而言不具备可见性。这就是缓存一致性问题。 缓存一致性(Cache Coherence)计算机的CPU与内存间有一层高速缓存作为缓冲，用于解决处理器与内存之间的速度矛盾。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。如果某一处理器将数据写会内存，其他处理器上的值是旧的，执行计算操作会有问题。为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期。 样例：多线程并发执行count += 1，结果往往可能和想象结果不一样。两个相同的线程同时执行，第一次都会将 count = 0 读入自己的CPU缓存，执行完之后各自的CPU缓存中的值都是1，同时写入内存后，内存中的值为1。 2. 线程切换带来的“原子性”问题现代操作系统的CPU调度都是使用时间片算法，经过特定时间片之后便会进行任务切换。曾经的操作系统基于进程调度CPU，不同进程不共享内存空间，进程切换要切换内存映射地址。而进程内的所有线程共享同一个内存区间，使用线程进行任务切换成本较低，所以现代操作系统更多基于轻量的线程进行调度，常说的CPU任务切换特指线程切换。 高级语言中的一条语句往往需要多个CPU指令完成。如 count += 1，需要三条指令： 将 count 值从内存中加载到CPU的寄存器中； 在CPU寄存器中执行 +1 操作； 将结果写会内存（也可能写回 CPU 高速缓存）。 而操作系统的任务切换是可以发生在任何一条CPU指令执行完，而非高级语言的一条语句。如果两个线程执行 count 操作，线程A执行指令1后，CPU切换到线程B，线程执行完 +1 操作后，将1写回内存，后又切换至线程A，线程A执行 +1 命令的结果是1，后又将count=1的结果写入内存。 一个或者多个操作在 CPU 执行的过程中不被中断的特性称为“原子性”。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符。 3. 编译优化带来的“有序性”问题编译器有时为了优化性能，有时会更改代码中的先后执行顺序。 示例：双重检查锁（无volatile） 123456789101112public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 执行new操作实际上执行的是： 分配一块内存M； 在内存M上初始化对象； 将 M 的地址赋值给示例对象。 但优化后的执行路径可能将2与3互换，当一个线程执行到内存地址赋值，切换到另一个线程，它会在第一个为空判断时直接返回 instance 对象，但 instance 对象没有初始化过，这时使用 instance 可能发生空指针异常。 CaseQ: 32位机器对 long 类型变量进行加减操作存在并发隐患的原因。 A: 因为64位的 long 类型在32位的机器上的操作必然是由多条CPU指令组合而成，是无法保证原子性的。 Referencehttps://time.geekbang.org/column/article/83682","categories":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/categories/concurrent/"}],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/tags/concurrent/"}]},{"title":"Alibaba Java开发手册 条目总结","slug":"Alibaba-Java开发手册-条目总结","date":"2019-08-18T04:44:50.000Z","updated":"2019-08-18T09:37:29.507Z","comments":true,"path":"2019/08/18/Alibaba-Java开发手册-条目总结/","link":"","permalink":"https://weilans.github.io/2019/08/18/Alibaba-Java开发手册-条目总结/","excerpt":"","text":"基于阿里巴巴Java开发手册（华山版）。 对部分重要的条目进行摘录，纯属个人总结，选择标准纯个人色彩，后续可以再过滤一下 Sonar Java Rules。 编程规约【强制】类名使用UpperCamelCase风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID等。 正例：JavaServerlessPlatform / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：javaserverlessplatform / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】POJO类中布尔类型变量都不要加is前缀，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型Boolean isDeleted的属性，它的方法也是isDeleted()，RPC框架在反向解析的时候，“误以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例：应用工具类包名为com.alibaba.ai.util、类名为MessageUtils（此规则参考spring的框架结构） 【强制】杜绝完全不规范的缩写，避免望文不知义。 反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 接口和实现类的命名有两套规则： 1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。 正例：CacheServiceImpl实现CacheService接口。 2） 【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able的形容词）。 正例：AbstractTranslator实现 Translatable接口。 【参考】各层命名规约： A) Service/DAO层方法命名规约 获取单个对象的方法用get做前缀。 获取多个对象的方法用list做前缀，复数形式结尾如：listObjects。 获取统计值的方法用count做前缀。 插入的方法用save/insert做前缀。 删除的方法用remove/delete做前缀。 修改的方法用update做前缀。 B) 领域模型命名规约 数据对象：xxxDO，xxx即为数据表名。 数据传输对象：xxxDTO，xxx为业务领域相关的名称。 展示对象：xxxVO，xxx一般为网页名称。 POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。 【强制】采用4个空格缩进，禁止使用tab字符。 说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。 【强制】注释的双斜线与注释内容之间有且仅有一个空格。 12// 这是示例注释，请注意在双斜线之后有一个空格 String param = new String(); 【推荐】单个方法的总行数不超过80行。 说明：除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80行。 正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。 【强制】所有的覆写方法，必须加@Override注解。 说明：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 正例：”test”.equals(object); 反例：object.equals(“test”); 说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）。 【强制】所有整型包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在 IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。 【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。 说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式 反例： 12345678910111213float a = 1.0f - 0.9f; float b = 0.9f - 0.8f; if (a == b) &#123; // 预期进入此代码快，执行其它业务逻辑 // 但事实上a==b的结果为false &#125; Float x = Float.valueOf(a); Float y = Float.valueOf(b); if (x.equals(y)) &#123; // 预期进入此代码快，执行其它业务逻辑 // 但事实上equals的结果为false &#125; 正例： 1234567891011121314151617// (1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。 float a = 1.0f - 0.9f; float b = 0.9f - 0.8f; float diff = 1e-6f; if (Math.abs(a - b) &lt; diff) &#123; System.out.println(\"true\"); s&#125; // (2) 使用BigDecimal来定义值，再进行浮点数的运算操作。 BigDecimal a = new BigDecimal(\"1.0\"); BigDecimal b = new BigDecimal(\"0.9\"); BigDecimal c = new BigDecimal(\"0.8\"); BigDecimal x = a.subtract(b); BigDecimal y = b.subtract(c); if (x.equals(y)) &#123; System.out.println(\"true\"); &#125; 【强制】定义数据对象DO类时，属性类型要与数据库字段类型相匹配。 正例：数据库字段的bigint必须与类属性的Long类型相对应。 反例：某个案例的数据库表id字段定义类型bigint unsigned，实际类对象属性为Integer，随着id越来越大，超过Integer的表示范围而溢出成为负数。 【强制】为了防止精度损失，禁止使用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象。 说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。如：BigDecimal g = new BigDecimal(0.1f); 实际的存储值为：0.10000000149 正例：优先推荐入参为String的构造方法，或使用BigDecimal的valueOf方法，此方法内部其实执行了Double的toString，而Double的toString按double的实际能表达的精度对尾数进行了截断。 1BigDecimal recommend1 = new BigDecimal(\"0.1\"); BigDecimal recommend2 = BigDecimal.valueOf(0.1); 关于基本数据类型与包装数据类型的使用标准如下： 1） 【强制】所有的POJO类属性必须使用包装数据类型。 2） 【强制】RPC方法的返回值和参数必须使用包装数据类型。 3） 【推荐】所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。 正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。 反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。 反例：POJO类的createTime默认值为new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。 说明：注意serialVersionUID不一致会抛出序列化运行时异常。 【强制】POJO类必须写toString方法。使用IDE中的工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。 说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。 【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。 说明： 1234String str = \"a,b,c,,\"; String[] ary = str.split(\",\"); // 预期大于3，结果是3 System.out.println(ary.length); 【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter 方法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。 【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。 说明：下例中，反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。 反例： 1234String str = \"start\"; for (int i = 0; i &lt; 100; i++) &#123; str = str + \"hello\"; &#125; 【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字： 1） 不允许被继承的类，如：String类。 2） 不允许修改引用的域对象。 3） 不允许被覆写的方法，如：POJO类的setter方法。 4） 不允许运行过程中重新赋值的局部变量。 5） 避免上下文重复使用一个变量，使用final可以强制重新定义一个变量，方便更好地进行重构。 【推荐】慎用Object的clone方法来拷贝对象。 说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。 【推荐】类成员与方法访问控制从严： 1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。 2） 工具类不允许有public或default构造方法。 3） 类非static成员变量并且与子类共享，必须是protected。 4） 类非static成员变量并且仅在本类使用，必须是private。 5） 类static成员变量如果仅在本类使用，必须是private。 6） 若是static成员变量，考虑是否为final。 7） 类成员方法只供类内部调用，必须是private。 8） 类成员方法只对继承类公开，那么限制为protected。 异常处理【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。 【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。 【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。 【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。 【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。 【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 日志规约【强制】所有日志文件至少保存15天，因为有些异常具备以“周”为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于6个月。 【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。 说明：因为String字符串的拼接会使用StringBuilder的append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。 正例：logger.debug(“Processing trade with id: {} and symbol: {}”, id, symbol); 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。 正例：logger.error(各类参数或者对象toString() + “_” + e.getMessage(), e); 【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。 说明：注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。 【推荐】尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。【强制】国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。","categories":[{"name":"java","slug":"java","permalink":"https://weilans.github.io/categories/java/"}],"tags":[{"name":"code standards","slug":"code-standards","permalink":"https://weilans.github.io/tags/code-standards/"}]},{"title":"Spring Data Redis 实践 (v2.1.7)","slug":"Spring-Data-Redis-实践-v2-1-7","date":"2019-08-15T12:59:09.000Z","updated":"2019-08-15T15:38:23.976Z","comments":true,"path":"2019/08/15/Spring-Data-Redis-实践-v2-1-7/","link":"","permalink":"https://weilans.github.io/2019/08/15/Spring-Data-Redis-实践-v2-1-7/","excerpt":"","text":"最近重写一个项目，在 SpringBoot 用的是最新的 GA 版本 2.1.7，缓存层使用了 Spring Data Redis。其实使用它是因为上一个项目也是用的这个框架，了解的程度还行，但不算细致。此外，因为以前直接使用 Redisson 的时候出现了内存泄漏（实际上也不是人家的锅，算是依赖的 Netty 版本的 bug），对 Redisson 总会心有余悸。但我真的得承认，Redisson 非常好用，如果项目中需要使用一些分布式的 API，比如分布式锁、优先级阻塞队列等，Redisson 是不二之选。其实与Redisson 做横向对比的应该是 Jedis，Spring Data Redis 是在 Jedis 上架了一层（boot 1.x）。但是这个项目对 Redis 的API 操作比较简单，所以就当仔细学习一下 Spring Data Redis了。 POM因为 Boot 版本升了 2.X，Spring Data Redis 的默认框架从 Jedis 换成了 Lettuce，后者主要突出基于 Netty 的事件驱动，容易发挥异步优势。但是由于真不了解以及学习成本的考量，还是使用了 Jedis。 POM文件中需移除 lettuce 的依赖，引入 Jedis。具体版本在 2.1.7.RELEASE 的 spring-boot-dependencies 文件中（lettuce 版本 5.1.8.RELEASE，jedis 版本 2.9.3）。 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; ConfigRedisConnectionFactory12345678910111213141516@Beanpublic RedisConnectionFactory redisConnectionFactory() &#123; redisConf = ...; RedisStandaloneConfiguration standaloneConf = new RedisStandaloneConfiguration( redisConf.getHost(), redisConf.getPort()); if (!Strings.isNullOrEmpty(redisConf.getPassword())) &#123; standaloneConf.setPassword(redisConf.getPassword()); &#125; JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(standaloneConf); GenericObjectPoolConfig poolConfig = jedisConnectionFactory.getPoolConfig(); poolConfig.setMaxTotal(30); poolConfig.setMinIdle(0); poolConfig.setMaxIdle(10); poolConfig.setMaxWaitMillis(3000); return jedisConnectionFactory;&#125; 2.x 的配置也和之前有所区别，JedisConnectionFactory的setXxx方法大多已是 Deprecated，如：setHostName、setPort、setPassword等。文档的提示内容是： since 2.0, configure the password using {@link RedisStandaloneConfiguration}, {@link RedisSentinelConfiguration} or {@link RedisClusterConfiguration}. 所以，在 JedisConnectionFactory 构造参数中设置RedisStandaloneConfiguration。而 pool 信息可以从 factory 中获取，从而进行设置。从 JedisConnectionFactory 构造函数中，我们发现它构造了MutableJedisClientConfiguration对象。该对象的 poolConfig 在 变量声名中就 new 出了JedisPoolConfig，我们可以对这个对象进行连接池设置。 123public JedisConnectionFactory(RedisStandaloneConfiguration standaloneConfig) &#123; this(standaloneConfig, new MutableJedisClientConfiguration());&#125; 当然设置 pool 信息不单只有这一种，MutableJedisClientConfiguration是JedisClientConfiguration接口的实现类，该接口下面还有接口JedisPoolingClientConfigurationBuilder，也可以使用它的实现类DefaultJedisClientConfigurationBuilder，JedisClientConfiguration.builder()返回的就是这个类实例。 感觉到了 2.x，手动建 Factory 配置有点麻烦啊… RedisTemplateRedisTemplate 的 配置比较简单，注入 RedisConnectionFactory Bean 对象即可，但是要注意的序列化方案。 12345678@Beanpublic RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); setSerializer(redisTemplate); redisTemplate.afterPropertiesSet(); return redisTemplate;&#125; 序列化12345678private void setSerializer(RedisTemplate&lt;String, Object&gt; template) &#123; GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(genericJackson2JsonRedisSerializer); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(genericJackson2JsonRedisSerializer);&#125; 在 redisTemplate.afterPropertiesSet()方法中，显示默认的序列化方式是JdkSerializationRedisSerializer。使用的是 JDK 序列化方式，数据以字节流的形式存储。这种方式会造成可读性很差。 12345678910111213141516171819202122232425if (defaultSerializer == null) &#123; defaultSerializer = new JdkSerializationRedisSerializer( classLoader != null ? classLoader : this.getClass().getClassLoader());&#125;if (enableDefaultSerializer) &#123; if (keySerializer == null) &#123; keySerializer = defaultSerializer; defaultUsed = true; &#125; if (valueSerializer == null) &#123; valueSerializer = defaultSerializer; defaultUsed = true; &#125; if (hashKeySerializer == null) &#123; hashKeySerializer = defaultSerializer; defaultUsed = true; &#125; if (hashValueSerializer == null) &#123; hashValueSerializer = defaultSerializer; defaultUsed = true; &#125;&#125; 如果项目中 key value 都只要使用字符串即可的话，StringRedisSerializer也是一种选项。这里我使用的是 Jackson 方式进行序列化操作。我事先使用的是Jackson2JsonRedisSerializer方式，该方式会将对象完全展为 JSON，但是在反序列的过程中报错：LinkedHashMap cannot be cast to ...，所以改成了GenericJackson2JsonRedisSerializer，该方案会在 JSON 中添加 @class类信息 field，这样在处理集合类泛型信息时，都能够正确处理。 使用 GenericJackson2JsonRedisSerializer 的时候，一开始是使用了自己定义的 ObjectMapper，结果发现无用，后来选择了无参构造器的实现才不出错。究其原因不难发现，该构造器中会对 objectMapper 设置 enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL)，正是该字段使 Jackson 生成了类信息字段，这才是允许反序列化的基础。而类的前面出现 @class 是因为 NullValueSerializer 里 设置了classIdentifier 为 @class（即 JsonTypeInfo.Id#CLASS）。 如果使用 Jackson2JsonRedisSerializer 时里面的 objectMapper 配置了 DefaultTyping.NON_FINAL，简单试验了一下发现序列化/反序列化操作会成功（没配 @class 前缀也是可以的）。 12345678910111213141516public GenericJackson2JsonRedisSerializer() &#123; this((String) null);&#125;public GenericJackson2JsonRedisSerializer(@Nullable String classPropertyTypeName) &#123; this(new ObjectMapper()); mapper.registerModule(new SimpleModule().addSerializer(new NullValueSerializer(classPropertyTypeName))); if (StringUtils.hasText(classPropertyTypeName)) &#123; mapper.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, classPropertyTypeName); &#125; else &#123; mapper.enableDefaultTyping(DefaultTyping.NON_FINAL, As.PROPERTY); &#125;&#125; 感觉一个完整 JSON 工具包的实现还是很难的，有机会可以详细过一遍 Jackson… 官方 Reference","categories":[{"name":"java","slug":"java","permalink":"https://weilans.github.io/categories/java/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://weilans.github.io/tags/cache/"},{"name":"spring","slug":"spring","permalink":"https://weilans.github.io/tags/spring/"},{"name":"redis","slug":"redis","permalink":"https://weilans.github.io/tags/redis/"}]},{"title":"[Leetcode单排] 二叉树的序列化与反序列化 (N297)","slug":"Leetcode单排-二叉树的序列化与反序列化-N297","date":"2019-08-12T14:41:41.000Z","updated":"2019-08-12T16:30:01.341Z","comments":true,"path":"2019/08/12/Leetcode单排-二叉树的序列化与反序列化-N297/","link":"","permalink":"https://weilans.github.io/2019/08/12/Leetcode单排-二叉树的序列化与反序列化-N297/","excerpt":"","text":"297. Serialize and Deserialize Binary Treehttps://leetcode.com/problems/serialize-and-deserialize-binary-tree/ 先序遍历每个节点用逗号分隔，空节点使用#表示。序列化二叉树肯定会想到先序、中序、后序、层次遍历四种，中序和后序从下往上推不好实现，剩下的考虑先序和层次。而先序遍历之所以可以应用，是因为每个分支都有明确的结束标记。序列化的时候，先确定自己，再确定左右。反序列化的过程，先获取头部，再判断左子节点，左子节点有结束边界，之后右子节点也按照边界结束。 123456789101112131415161718192021222324252627282930313233public String serialize(TreeNode root) &#123; if (root == null) &#123; return \"#,\"; &#125; String curStr = root.val + \",\"; String leftStr = serialize(root.left); String rightStr = serialize(root.right); return curStr + leftStr + rightStr;&#125;public TreeNode deserialize(String data) &#123; if (data == null) &#123; return null; &#125; String[] strArr = data.split(\",\"); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); for (String str : strArr) &#123; queue.offer(str); &#125; return deserialize(queue);&#125;private TreeNode deserialize(Queue&lt;String&gt; queue) &#123; String str = queue.poll(); if (str.equals(\"#\")) &#123; return null; &#125; TreeNode node = new TreeNode(Integer.parseInt(str)); node.left = deserialize(queue); node.right = deserialize(queue); return node;&#125; 层次遍历层次遍历写起来稍微有点复杂，但是更好理解。序列化的时候，先把顶部节点放至 queue 中，依据左右节点值放至 StringBuilder 中，再按照是否为空，将不为空的放入队列中进行下一层的遍历。反序列化同样是新建一个队列放入头结点，将左右节点非空的放入队列中，进行下一层的从左到右的解析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public String serialize(TreeNode root) &#123; if (root == null) &#123; return null; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 注意 root.val 别放到构造函数里，因为: new StringBuilder(int capacity) StringBuilder sb = new StringBuilder().append(root.val).append(\",\"); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); TreeNode left = node.left; TreeNode right = node.right; if (left != null) &#123; sb.append(left.val).append(\",\"); queue.offer(left); &#125; else &#123; sb.append(\"#,\"); &#125; if (right != null) &#123; sb.append(right.val).append(\",\"); queue.offer(right); &#125; else &#123; sb.append(\"#,\"); &#125; &#125; return sb.toString(); &#125; public TreeNode deserialize(String data) &#123; if (data == null || data == \"\") &#123; return null; &#125; String[] strArr = data.split(\",\"); int index = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = buildNode(strArr[0]); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); TreeNode left = buildNode(strArr[++index]); TreeNode right = buildNode(strArr[++index]); node.left = left; node.right = right; if (left != null) &#123; queue.offer(left); &#125; if (right != null) &#123; queue.offer(right); &#125; &#125; return root; &#125; private TreeNode buildNode(String str) &#123; if (\"#\".equals(str)) &#123; return null; &#125; return new TreeNode(Integer.parseInt(str)); &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://weilans.github.io/tags/tree/"}]},{"title":"[Leetcode单排] 树类题目集合1 (N102 N107 N429 N872 N112 N113)","slug":"Leetcode单排- 树类题目集合1-N102-N107-N429-N872-N112-N113","date":"2019-08-10T02:10:54.000Z","updated":"2019-08-18T09:50:51.724Z","comments":true,"path":"2019/08/10/Leetcode单排- 树类题目集合1-N102-N107-N429-N872-N112-N113/","link":"","permalink":"https://weilans.github.io/2019/08/10/Leetcode单排- 树类题目集合1-N102-N107-N429-N872-N112-N113/","excerpt":"","text":"102. Binary Tree Level Order Traversalhttps://leetcode.com/problems/binary-tree-level-order-traversal/ 层次遍历，但是题目需要把每一层的放到一个 List 里面，这里用的是计数（需要注意先把左右节点放到队列中再进行数量判断）。当然也可以使用在 while 最开始获取 队列中的 size 作为这一层的大小，之后里面加一层 for 循环，详见此。 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 1, temp = 0, next = 0; List&lt;Integer&gt; layer = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); int val = node.val; layer.add(val); if (node.left != null) &#123; queue.offer(node.left); next++; &#125; if (node.right != null) &#123; queue.offer(node.right); next++; &#125; if (++temp == count) &#123; result.add(new ArrayList&lt;&gt;(layer)); layer.clear(); count = next; next = 0; temp = 0; &#125; &#125; return result; &#125; 107. Binary Tree Level Order Traversal IIhttps://leetcode.com/problems/binary-tree-level-order-traversal-ii/ 这道题就很没意思了，每次只要加在 List 的最前面就可以了。 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 1, temp = 0, next = 0; List&lt;Integer&gt; layer = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); int val = node.val; layer.add(val); if (node.left != null) &#123; queue.offer(node.left); next++; &#125; if (node.right != null) &#123; queue.offer(node.right); next++; &#125; if (++temp == count) &#123; result.add(0, new ArrayList&lt;&gt;(layer)); layer.clear(); count = next; next = 0; temp = 0; &#125; &#125; return result; &#125; 429. N-ary Tree Level Order Traversalhttps://leetcode.com/problems/n-ary-tree-level-order-traversal/ 依然是层次遍历，只不过二叉树换成 N 叉树。 1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 1, temp = 0, next = 0; List&lt;Integer&gt; layer = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; Node node = queue.poll(); int val = node.val; layer.add(val); if (node.children != null &amp;&amp; node.children.size() !=0) &#123; for (Node n : node.children) &#123; queue.offer(n); next++; &#125; &#125; if (++temp == count) &#123; result.add(new ArrayList&lt;&gt;(layer)); layer.clear(); count = next; next = 0; temp = 0; &#125; &#125; return result;&#125; 872. Leaf-Similar Treeshttps://leetcode.com/problems/leaf-similar-trees/ 判断两颗二叉树的叶子节点（从左到右）是否相等。这里用的比较常规做法，使用中序遍历，把打印换成判断是否为叶子节点。 12345678910111213141516171819202122232425262728public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; if (root1 == null &amp;&amp; root2 == null) &#123; return true; &#125; if (root1 == null || root2 == null) &#123; return false; &#125; List&lt;Integer&gt; leaves1 = getLeaves(root1); List&lt;Integer&gt; leaves2 = getLeaves(root2); return leaves1.equals(leaves2); &#125; private List&lt;Integer&gt; getLeaves(TreeNode node) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inorder(node, list); return list; &#125; private void inorder(TreeNode node, List&lt;Integer&gt; list) &#123; if (node == null) &#123; return; &#125; inorder(node.left, list); if (node.left == null &amp;&amp; node.right == null) &#123; list.add(node.val); &#125; inorder(node.right, list); &#125; 112. Path Sumhttps://leetcode.com/problems/path-sum/ 这里的递归没有去判断是否为 null ，因为为 null 的情形本身就被排除了。（另外，此类是否存在一个满足条件的问题，当有情况成功时，需要立刻返回。总是遗漏掉 if 为 true，立刻返回的情形。） 1234567891011121314151617181920212223public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return false; &#125; return dfs(root, 0, sum); &#125; private boolean dfs(TreeNode node, int curSum, int target) &#123; if (node.left == null &amp;&amp; node.right == null) &#123; return target == curSum + node.val; &#125; if (node.left != null) &#123; if (dfs(node.left, curSum + node.val, target)) &#123; return true; &#125; &#125; if (node.right != null) &#123; if (dfs(node.right, curSum + node.val, target)) &#123; return true; &#125; &#125; return false; &#125; 别人写的更精炼 1234567public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);&#125; 113. Path SumIIhttps://leetcode.com/problems/path-sum-ii/ 第一次写成的版本比较糙。当前节点不满足进行下一轮左右节点递归时，都加上了add和remove方法，这是传统 回溯 做多了的惯性，但实际上这两种情形加上删除的值是相同的，所以可以进行精简。 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; dfs(root, sum, new ArrayList&lt;&gt;(), result); return result;&#125;private void dfs(TreeNode node, int curSum, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (node == null) &#123; return; &#125; if (curSum - node.val == 0 &amp;&amp; node.left == null &amp;&amp; node.right == null) &#123; curList.add(node.val); result.add(new ArrayList&lt;&gt;(curList)); curList.remove(curList.size() - 1); return; &#125; curList.add(node.val); dfs(node.left, curSum - node.val, curList, result); curList.remove(curList.size() - 1); curList.add(node.val); dfs(node.right, curSum - node.val, curList, result); curList.remove(curList.size() - 1);&#125; clean version: 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; dfs(root, sum, new ArrayList&lt;&gt;(), result); return result;&#125;private void dfs(TreeNode node, int curSum, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (node == null) &#123; return; &#125; curList.add(node.val); if (curSum - node.val == 0 &amp;&amp; node.left == null &amp;&amp; node.right == null) &#123; result.add(new ArrayList&lt;&gt;(curList)); curList.remove(curList.size() - 1); return; &#125; dfs(node.left, curSum - node.val, curList, result); dfs(node.right, curSum - node.val, curList, result); curList.remove(curList.size() - 1);&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://weilans.github.io/tags/tree/"}]},{"title":"[Leetcode单排] 树相关Easy题 (N100 N101 N104 N110 N111 N572 N965)","slug":"Leetcode单排-树相关Easy题-N100-N101-N104-N110-N111-N572-N965","date":"2019-08-09T11:02:14.000Z","updated":"2019-08-18T09:51:32.775Z","comments":true,"path":"2019/08/09/Leetcode单排-树相关Easy题-N100-N101-N104-N110-N111-N572-N965/","link":"","permalink":"https://weilans.github.io/2019/08/09/Leetcode单排-树相关Easy题-N100-N101-N104-N110-N111-N572-N965/","excerpt":"","text":"100. Same Treehttps://leetcode.com/problems/same-tree/ 123456789101112public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; if (p == null || q == null) &#123; return false; &#125; if (p.val != q.val) &#123; return false; &#125; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125; 101. Symmetric Treehttps://leetcode.com/problems/symmetric-tree/ 12345678910111213141516171819public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return check(root.left, root.right); &#125; private boolean check(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; if (p == null || q == null) &#123; return false; &#125; if (p.val != q.val) &#123; return false; &#125; return check(p.left, q.right) &amp;&amp; check(p.right, q.left); &#125; 104. Maximum Depth of Binary Treehttps://leetcode.com/problems/maximum-depth-of-binary-tree/ 12345678public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1;&#125; 110. Balanced Binary Treehttps://leetcode.com/problems/balanced-binary-tree/ （第一回做的时候，犯了个小错误，求出leftDepth及rightDepth为 null 时，需要立即退出返回 null。） 123456789101112131415161718192021222324public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return depth(root) != null;&#125;private Integer depth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; Integer leftDepth = depth(root.left); if (leftDepth == null) &#123; return null; &#125; Integer rightDepth = depth(root.right); if (rightDepth == null) &#123; return null; &#125; if (Math.abs(leftDepth - rightDepth) &gt; 1) &#123; return null; &#125; return Math.max(leftDepth, rightDepth) + 1;&#125; 111. Minimum Depth of Binary Treehttps://leetcode.com/problems/minimum-depth-of-binary-tree/ 与求最大高度相比，求最小高度特别之处在于：如果左右有一个高度为 0，则另一个的高度即为返回值。 1234567891011121314public int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (leftDepth == 0) &#123; return rightDepth + 1; &#125; if (rightDepth == 0) &#123; return leftDepth + 1; &#125; return Math.min(leftDepth, rightDepth) + 1; &#125; 572. Subtree of Another Treehttps://leetcode.com/problems/subtree-of-another-tree/ 我这里是想先层次遍历找到值相同的点后，再检验两个树是否相等。当然也可以使用isSubtree(s.left, t) || isSubtree(s.right, t)的形式递归判断。 123456789101112131415161718192021222324252627282930public boolean isSubtree(TreeNode s, TreeNode t) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(s); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if (node != null &amp;&amp; t != null &amp;&amp; node.val == t.val &amp;&amp; check(node, t)) &#123; return true; &#125; if (node != null &amp;&amp; node.left != null) &#123; queue.offer(node.left); &#125; if (node != null &amp;&amp; node.right != null) &#123; queue.offer(node.right); &#125; &#125; return false;&#125;private boolean check(TreeNode n1, TreeNode n2) &#123; if (n1 == null &amp;&amp; n2 == null) &#123; return true; &#125; if (n1 == null || n2 == null) &#123; return false; &#125; if (n1.val != n2.val) &#123; return false; &#125; return check(n1.left, n2.left) &amp;&amp; check(n1.right, n2.right);&#125; 递归的做法如下（可以看作是先序递归遍历）： 12345public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null) return false; if (check(s, t)) return true; return isSubtree(s.left, t) || isSubtree(s.right, t); &#125; 965. Univalued Binary Treehttps://leetcode.com/problems/univalued-binary-tree/ 12345678910111213141516171819202122public boolean isUnivalTree(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int temp = root.val; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if (node.val != temp) &#123; return false; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return true; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://weilans.github.io/tags/tree/"}]},{"title":"[Leetcode单排] 树的遍历 (N94 N589 N590)","slug":"Leetcode单排-树的遍历-N94-N589-N590","date":"2019-08-09T08:15:52.000Z","updated":"2019-08-09T10:25:02.526Z","comments":true,"path":"2019/08/09/Leetcode单排-树的遍历-N94-N589-N590/","link":"","permalink":"https://weilans.github.io/2019/08/09/Leetcode单排-树的遍历-N94-N589-N590/","excerpt":"","text":"94. Binary Tree Inorder Traversalhttps://leetcode.com/problems/binary-tree-inorder-traversal/ 先简单回顾下二叉树的遍历，分为先序、中序、后序三种方式，每一种有都有递归和非递归两种方式。先回顾递归的方式。 递归1234567891011121314151617181920212223242526272829303132333435/** * 先序遍历 递归 */public void preOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.value + \" \"); preOrderRecur(head.left); preOrderRecur(head.right);&#125;/** * 中序遍历 递归 */public void inOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; inOrderRecur(head.left); System.out.print(head.value + \" \"); inOrderRecur(head.right);&#125;/** * 后序遍历 递归 */public void posOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; posOrderRecur(head.left); posOrderRecur(head.right); System.out.print(head.value + \" \");&#125; 虽然递归方式的代码的样子很简单，但还是需要好好理解的。如果把节点的访问顺序一个个的记录下来，会发现每个节点会访问三次。如果把处理时机放在第一次来到这个节点的时候就是先续遍历，放在第二次就是中序遍历，放在第三次就是后续遍历。 非递归先序遍历：先将头结点放入栈中，之后在 while 中不断弹出。弹出节点有右节点即将其放入栈中，之后有左子树将其放放入栈中。不使用队列的原因是：先序遍历虽然只能往下走，但是遍历完左子树之后还是需要回去的，所以非递归中序遍历需要用栈结构。 12345678910111213141516171819 /** * 先序遍历 非递归 */public void preOrderUnRecur(Node head) &#123; if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.add(head); while (!stack.isEmpty()) &#123; head = stack.pop(); System.out.print(head.value + \" \"); if (head.right != null) &#123; stack.push(head.right); &#125; if (head.left != null) &#123; stack.push(head.left); &#125; &#125; &#125;&#125; 中序遍历：当前节点一定会把自己的左边界都压到栈里去，其实简略概括为：当前节点为空，从栈顶拿一个打印，当前节点往右边跑；当前节点不为空，当前节点压入栈，当前节点往左。 中序直接从头部节点开始，不需要事先压栈。 123456789101112131415161718/** * 中序遍历 非递归 */public void inOrderUnRecur(Node head) &#123; if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (!stack.isEmpty() || head != null) &#123; if (head != null) &#123; stack.push(head); head = head.left; &#125; else &#123; head = stack.pop(); System.out.print(head.value + \" \"); head = head.right; &#125; &#125; &#125;&#125; 后序遍历：左右中是中右左的逆序，而中左右即为先序遍历，所以中右左是容易实现的。所以可以将中右左弹出的元素压入另一个栈中即可，这就是双栈的做法。单栈的做法不好理解，就不展开了。 1234567891011121314151617181920212223/** * 后序遍历 非递归（双栈） */public void posOrderUnRecur1(Node head) &#123; if (head != null) &#123; Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;(); s1.push(head); while (!s1.isEmpty()) &#123; head = s1.pop(); s2.push(head); if (head.left != null) &#123; s1.push(head.left); &#125; if (head.right != null) &#123; s1.push(head.right); &#125; &#125; while (!s2.isEmpty()) &#123; System.out.print(s2.pop().value + \" \"); &#125; &#125;&#125; 所以 92 题非递归就是如下的写法： 1234567891011121314151617181920class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; if (root != null) &#123; stack.push(root); root = root.left; &#125; else &#123; TreeNode p = stack.pop(); result.add(p.val); root = p.right; &#125; &#125; return result; &#125;&#125; 589. N-ary Tree Preorder Traversalhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/ 递归1234567891011121314151617181920public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; preorder(result, root); return result;&#125;private void preorder(List&lt;Integer&gt; result, Node cur) &#123; if (cur == null) &#123; return; &#125; result.add(cur.val); if (cur.children != null &amp;&amp; cur.children.size() != 0) &#123; for (Node child : cur.children) &#123; preorder(result, child); &#125; &#125;&#125; 非递归12345678910111213141516171819202122public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node node = stack.pop(); result.add(node.val); if (node.children != null &amp;&amp; node.children.size() != 0) &#123; // 先右后左 for (int i = node.children.size() - 1; i &gt;= 0; i--) &#123; Node child = node.children.get(i); if (child != null) &#123; stack.push(child); &#125; &#125; &#125; &#125; return result; &#125; 590. N-ary Tree Postorder Traversalhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/ 递归1234567891011121314151617181920public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; postorder(result, root); return result;&#125;private void postorder(List&lt;Integer&gt; result, Node cur) &#123; if (cur == null) &#123; return; &#125; if (cur.children != null &amp;&amp; cur.children.size() != 0) &#123; for (Node child : cur.children) &#123; postorder(result, child); &#125; &#125; result.add(cur.val);&#125; 非递归(双栈)12345678910111213141516171819202122232425public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; Stack&lt;Node&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Node&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root); while (!stack1.isEmpty()) &#123; Node node = stack1.pop(); stack2.push(node); if (node.children != null &amp;&amp; node.children.size() != 0) &#123; // 先左后右 for (Node child : node.children) &#123; if (child != null) &#123; stack1.push(child); &#125; &#125; &#125; &#125; while (!stack2.isEmpty()) &#123; result.add(stack2.pop().val); &#125; return result;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://weilans.github.io/tags/tree/"}]},{"title":"[Leetcode单排] 划分为k个相等的子集 (N698)","slug":"Leetcode单排-划分为k个相等的子集-N698","date":"2019-08-04T15:54:41.000Z","updated":"2019-08-04T17:09:06.503Z","comments":true,"path":"2019/08/04/Leetcode单排-划分为k个相等的子集-N698/","link":"","permalink":"https://weilans.github.io/2019/08/04/Leetcode单排-划分为k个相等的子集-N698/","excerpt":"","text":"698. Partition to K Equal Sum Subsetshttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/ （最近做了挺多的DFS题目，这道题没做出来 o.O||，还是菜啊 ）做法来自 小f讲解。这道题目本以为会有其他的方法，最后也只能不断暴力递归求解。递归时先建立指定个数的桶，每个桶内数字总和是相等的。partation方法的含义是每个下标在这几个桶内都能够放下，只要满足这个条件即返回成功。只要找到一种可行方式即可。 求总和时用了Arrays.stream().sum()方法结果耗时 47ms，换手动计算变成 13ms。所以数据集有限的情况下，算法题还是谨慎用流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &lt;= 0) &#123; return false; &#125; int sum = sum(nums); // 校验1：除有余数，无法均分 if (sum % k != 0) &#123; return false; &#125; Arrays.sort(nums); int subSum = sum / k; int index = nums.length - 1; // 校验2：最大值比平均值大，及无法均分 if (nums[index] &gt; subSum) &#123; return false; &#125; int subNum = k; while (index &gt;= 0 &amp;&amp; nums[index] == subSum) &#123; index--; subNum--; &#125; return partition(nums, subSum, index, new int[subNum]);&#125;private boolean partition(int[] num, int target, int index, int[] subSet) &#123; if (index &lt; 0) &#123; return true; &#125; // 当前值在这几个桶内是否有地方可放置 for (int i = 0; i &lt; subSet.length; i++) &#123; if (subSet[i] + num[index] &lt;= target) &#123; subSet[i] += num[index]; if (partition(num, target, index - 1, subSet)) &#123; return true; &#125; subSet[i] -= num[index]; &#125; &#125; return false;&#125;private int sum(int[] array) &#123; int sum = 0; for (int i : array) &#123; sum += i; &#125; return sum;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"[Leetcode单排] 01矩阵 (N542)","slug":"Leetcode单排-01矩阵-N542","date":"2019-08-04T14:07:00.000Z","updated":"2019-08-04T14:37:49.321Z","comments":true,"path":"2019/08/04/Leetcode单排-01矩阵-N542/","link":"","permalink":"https://weilans.github.io/2019/08/04/Leetcode单排-01矩阵-N542/","excerpt":"","text":"542. 01 Matrixhttps://leetcode.com/problems/01-matrix/ BFS问题，第一感觉是使用队列来做。先对原数组进行处理，将 0 的下标入队列，非零下标记为最大Integer值。之后由每个0的四周逐渐散开，覆盖掉其四周的 Integer.MAX_VALUE。这样对于处理过的坐标，后续其他 0 散开达到时，其距离一定比当前值大，也就不用处理了。 12345678910111213141516171819202122232425262728293031public int[][] updateMatrix(int[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return null; &#125; int row = matrix.length; int col = matrix[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (matrix[i][j] == 0) &#123; queue.offer(new int[]&#123;i, j&#125;); &#125; else &#123; matrix[i][j] = Integer.MAX_VALUE; &#125; &#125; &#125; int[][] neigh = new int[][]&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; while (!queue.isEmpty()) &#123; int[] idx = queue.poll(); for (int[] nei : neigh) &#123; int i = idx[0] + nei[0]; int j = idx[1] + nei[1]; if (i &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; col &amp;&amp; matrix[i][j] &gt; matrix[idx[0]][idx[1]] + 1) &#123; matrix[i][j] = matrix[idx[0]][idx[1]] + 1; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; return matrix;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"bfs","slug":"bfs","permalink":"https://weilans.github.io/tags/bfs/"}]},{"title":"[Leetcode单排] 运算表达式设优先级求值 (N241)","slug":"Leetcode单排-运算表达式设优先级求值-N241","date":"2019-08-04T08:46:02.000Z","updated":"2019-08-04T12:30:44.119Z","comments":true,"path":"2019/08/04/Leetcode单排-运算表达式设优先级求值-N241/","link":"","permalink":"https://weilans.github.io/2019/08/04/Leetcode单排-运算表达式设优先级求值-N241/","excerpt":"","text":"241. Different Ways to Add Parentheseshttps://leetcode.com/problems/different-ways-to-add-parentheses/ 自己做的感觉不太好，听了花花酱的讲解后写了一版Java的，时间和内存可以达到都是 100%。 这道题目的关键在于： 递归的方式是按照操作符拆成左右两边表达式，左边的 List 和 右边的 List 进行笛卡尔积处理（以该操作符处理）。 递归的终止条件是字符串本身是个数值，没有操作符，那结果就将其放入到一个新 List 中返回。 重复计算：以用例2*3-4*5来说，计算方式可以有(2*(3-(4*5)))以及((2*3)-(4*5))，这里面的4*5会重复计算到，所有可以使用 map 记住字符串的计算结果。 试了下不带缓存的版本：Runtime: 2 ms, faster than 75.34%；Memory Usage: 38.6 MB, less than 65.42%，效果依然是不错的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; if (input == null || input.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; return handle(input, new HashMap&lt;&gt;());&#125;private List&lt;Integer&gt; handle(String str, Map&lt;String, List&lt;Integer&gt;&gt; cache) &#123; if (cache.containsKey(str)) &#123; return cache.get(str); &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); if (ch != '+' &amp;&amp; ch != '-' &amp;&amp; ch != '*') &#123; continue; &#125; String left = str.substring(0, i); String right = str.substring(i + 1); List&lt;Integer&gt; leftList = handle(left, cache); List&lt;Integer&gt; rightList = handle(right, cache); for (Integer l : leftList) &#123; for (Integer r : rightList) &#123; result.add(calculate(ch, l, r)); &#125; &#125; &#125; // str 为数字 if (result.size() == 0) &#123; result.add(Integer.parseInt(str)); &#125; cache.put(str, result); return result;&#125;private Integer calculate(char ch, Integer left, Integer right) &#123; if (ch == '+') &#123; return left + right; &#125; if (ch == '-') &#123; return left - right; &#125; if (ch == '*') &#123; return left * right; &#125; throw new IllegalArgumentException(\"incorrect char\");&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"partition","slug":"partition","permalink":"https://weilans.github.io/tags/partition/"}]},{"title":"[Leetcode单排] 分割回文串 (N131)","slug":"Leetcode单排-分割回文串-N131","date":"2019-08-04T07:13:47.000Z","updated":"2019-08-04T12:20:53.000Z","comments":true,"path":"2019/08/04/Leetcode单排-分割回文串-N131/","link":"","permalink":"https://weilans.github.io/2019/08/04/Leetcode单排-分割回文串-N131/","excerpt":"","text":"131. Palindrome Partitioninghttps://leetcode.com/problems/palindrome-partitioning/ DFS 回溯 典型问题。基本同 N93 复原IP地址问题。 需要注意的是 handle方法里面 for 的终止条件，一开始写的是i &lt; str.length()，发现最后一个字符总是漏掉，主要是 substring 的第二个参数在截取的时候 exclude，i 这个值本身可以等于 length。 12345678910111213141516171819202122232425262728293031323334353637public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return result; &#125; handle(s, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(String str, int index, List&lt;String&gt; curList, List&lt;List&lt;String&gt;&gt; result) &#123; if (index == str.length()) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; for (int i = index + 1; i &lt;= str.length(); i++) &#123; if (isPalindrome(str.substring(index, i))) &#123; curList.add(str.substring(index, i)); handle(str, i, curList, result); curList.remove(curList.size() - 1); &#125; &#125;&#125;private boolean isPalindrome(String str) &#123; if (str == null || str.length() == 0) &#123; return false; &#125; if (str.length() == 1) &#123; return true; &#125; for (int i = 0; i &lt; str.length() / 2; i++) &#123; if (str.charAt(i) != str.charAt(str.length() - i - 1)) &#123; return false; &#125; &#125; return true;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"partition","slug":"partition","permalink":"https://weilans.github.io/tags/partition/"}]},{"title":"[Leetcode单排] 复原IP地址 (N93)","slug":"Leetcode单排-复原IP地址-N93","date":"2019-08-04T06:02:33.000Z","updated":"2019-08-04T12:19:18.984Z","comments":true,"path":"2019/08/04/Leetcode单排-复原IP地址-N93/","link":"","permalink":"https://weilans.github.io/2019/08/04/Leetcode单排-复原IP地址-N93/","excerpt":"","text":"93. Restore IP Addresseshttps://leetcode.com/problems/restore-ip-addresses/ DFS 回溯 典型问题，只要稍微留意一下为 0 的情况就可以了。 需要留意的是终止条件fields == 4 || index == chars.length。之前误写的是fields &gt; 4 || index == chars.length，导致内存 less than 5%。本以为是递归数据结构用的不好，结果发现只要内存用得多，那就应该想到是递归本身条件写的有问题。改回等号后 less than 100%。 123456789101112131415161718192021222324252627282930public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return result; &#125; search(s.toCharArray(), 0,0, \"\", result); return result; &#125; private void search(char[] chars, int index, int fields, String cur, List&lt;String&gt; result) &#123; if (fields == 4 &amp;&amp; index == chars.length) &#123; result.add(cur.substring(0, cur.length() - 1)); return; &#125; // 注意终止条件 if (fields == 4 || index == chars.length) &#123; return; &#125; if (chars[index] == '0') &#123; search(chars, index + 1, fields + 1, cur + new String(chars, index, 1) + \".\", result); &#125; else &#123; if (index + 2 &lt; chars.length &amp;&amp; Integer.parseInt(new String(chars, index, 3)) &lt;= 255) &#123; search(chars, index + 3, fields + 1, cur + new String(chars, index, 3) + \".\", result); &#125; if (index + 1 &lt; chars.length) &#123; search(chars, index + 2, fields + 1, cur + new String(chars, index, 2) + \".\", result); &#125; search(chars, index + 1, fields + 1, cur + new String(chars, index, 1) + \".\", result); &#125; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"partition","slug":"partition","permalink":"https://weilans.github.io/tags/partition/"}]},{"title":"[Java并发札记] 3.Lock","slug":"Java并发札记-3-Lock","date":"2019-08-03T17:13:48.000Z","updated":"2019-08-28T06:32:15.272Z","comments":true,"path":"2019/08/04/Java并发札记-3-Lock/","link":"","permalink":"https://weilans.github.io/2019/08/04/Java并发札记-3-Lock/","excerpt":"","text":"LockLock接口123456789101112// 获取锁，当锁获得后，从该方法处返回void lock(); // 获取锁的过程能够响应中断 void lockInterruptibly() throws InterruptedException；// 非阻塞式获取锁，获取锁放回true反之返回fasle boolean tryLock();// 超时获取锁，在超时内或者未中断的情况下能够获取锁boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 释放锁void unlock(); // 获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回Condition newCondition(); Lock与synchronized相比拥有的优势 可响应中断。synchronized 会在线程持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，而且一旦发生死锁，就没有任何机会来唤醒阻塞的线程。lockInterruptibly()可响应中断信号，可以在锁的获取过程中中断当前线程，调用thread.interrupt()方法能够中断线程的等待过程。 支持超时。tryLock(long time, TimeUnit unit)方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。 非阻塞获取锁。 tryLock()方法会尝试获取锁，如果获取成功则返回true，如果获取失败则返回 false，也就说这个方法无论如何都会立即返回。 除此之外，synchronized 会隐式获取锁，且会自动释放锁，而 Lock 是显式的获取锁，手工释放（synchronized 固化了锁的获取和释放，而 Lock相对的提供了更好的拓展性）；Lock可以绑定多个条件：Condition，await，signal。synchronized的wait，notify只可以实现一种条件。 AbstractQueuedSynchronizer队列同步器AbstractQueuedSynchronizer是用来构建锁或者其他同步组件的基础框架,它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。 同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法（·getState()、setState(int newState)、compareAndSetState(int expect, int update)）来管理同步状态。子类被推荐为自定义同步组件的静态内部类。同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程排队、等待与唤醒等底层操作细节。 AQS可重写的方法： 方法名称 描述 tryAcquire(int arg) 独占获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期状态，然后再进行CAS设置同步状态。 tryRelease(int arg) 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态 tryAcquireShared(int arg) 共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败 tryReleaseShared(int arg) 共享式释放同步状态 isHeldExclusively() 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占 AQS提供的模板方法： AQS使用示例12345678910111213141516171819202122232425262728293031323334353637383940class Mutex implements Lock &#123; // 静态内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer &#123; // 是否处于占用状态 protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 当状态为0的时候获取锁 public boolean tryAcquire(int acquires) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // 释放锁，将状态设置为0 protected boolean tryRelease(int releases) &#123; if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // 返回一个Condition，每个condition都包含了一个condition队列 Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; // 仅需要将操作代理到Sync上即可 private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; AQS实现分析同步队列当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。 同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部。 设置尾节点：加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。 设置首节点：首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证。 独占式同步状态获取与释放12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是： tryAcquire(int arg)，该方法保证线程安全的获取同步状态； 如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部； 最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。 12345678910111213141516171819202122232425262728293031private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // 快速尝试在尾部添加 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 同步器通过死循环来保证节点的正确添加 enq(node); return node;&#125;private Node enq(final Node node) &#123; for (; ; ) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。非首节点线程前驱节点出队或者被中断而从等待状态返回，随后检查自己的前驱是否是头节点，如果是则尝试获取同步状态。可以看到节点和节点之间在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合FIFO，并且也便于对过早通知的处理（过早通知是指前驱节点不是头节点的线程由于中断而被唤醒）。 同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 自定义同步组件 TwinsLockTwinsLock: 只允许至多两个线程访问，超过两个线程的访问将被阻塞 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class TwinsLock implements Lock &#123; /** * 自定义的同步器，能够有两个线程同时获取资源 */ private final Sync sync = new Sync(2); private static final class Sync extends AbstractQueuedSynchronizer &#123; Sync(int count) &#123; if (count &lt;= 0) &#123; throw new IllegalArgumentException(\"count must large than zero.\"); &#125; setState(count); &#125; @Override public int tryAcquireShared(int reduceCount) &#123; for (; ; ) &#123; int current = getState(); int newCount = current - reduceCount; if (newCount &lt; 0 || compareAndSetState(current, newCount)) &#123; return newCount; &#125; &#125; &#125; @Override public boolean tryReleaseShared(int returnCount) &#123; for (; ; ) &#123; int current = getState(); int newCount = current + returnCount; if (compareAndSetState(current, newCount)) &#123; // 将释放的资源返回 return true; &#125; &#125; &#125; Condition newCondtion() &#123; return new ConditionObject(); &#125; &#125; @Override public void lock() &#123; sync.acquireShared(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; @Override public boolean tryLock() &#123; return sync.tryAcquireShared(1) &gt;= 0; &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; sync.releaseShared(1); &#125; @Override public Condition newCondition() &#123; return sync.newCondtion(); &#125;&#125; ReentrantLockReentrantLock，支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁。前文中的Mutex，当一个线程调用lock()方法获取锁之后，若再次调用lock()方法，则该线程将会被自己所阻塞。 synchronized关键字隐式的支持重进入，递归方法不会阻塞自己，synchronized是非公平的。 此外，该锁还支持公平和非公平选择。锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。 公平锁能减少”饥饿”发生的概率。要实现公平锁必然要求系统维护一个有序队列，因此公平锁的实现成本比较高，性能相对也非常低下，因此，默认情况下，锁是非公平的。如果没有特别的需求，也不需要使用公平锁。 Lock的可见性保证也可以使用ReentrantLock来举例。ReentrantLock 内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值。可以通过 volatile 变量规则、顺序性规则以及传递性规则推导出 前一个线程在加锁时对变量的修改 Happens-Before 于另一个线程的加锁操作。 实现重进入该特性需要解决两个问题： 线程再次获取锁。锁需要识别获取锁的线程是否为当前占据锁的线程； 锁的最终释放。需要进行计数自增，计数表示当前锁被重复获取的次数，锁释放时，计数自减，当计数等于0时表示锁已经成功释放。 以非公平锁实现举例： 1234567891011121314151617181920212223242526272829303132final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; // 判断当前线程是否为获取锁的线程 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125;protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; 公平锁与非公平锁非公平锁，在nonfairTryAcquire(int acquires)方法中只需要CAS设置同步状态成功，即表示当前线程获取了锁。在这个前提下，刚释放锁的线程再次获取同步状态的几率会非常大。 公平锁，与非公平锁实现的唯一不同在于判断条件多了个hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱结点的判断。公平锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。 12345678910111213141516171819protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125; ReentrantReadWriteLock读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，能够简化读写交互场景的编程方式。 ReentrantReadWriteLock支持公平性/非公平性选择、重进入、锁降级。样例如下： 12345678910111213141516171819202122232425262728293031323334public class ReadWriteLockTest &#123; static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); static Lock r = rwl.readLock(); static Lock w = rwl.writeLock(); // 获取一个key对应的value public static final Object get(String key) &#123; r.lock(); try &#123; return map.get(key); &#125; finally &#123; r.unlock(); &#125; &#125; // 设置key对应的value，并返回旧的value public static final Object put(String key, Object value) &#123; w.lock(); try &#123; return map.put(key, value); &#125; finally &#123; w.unlock(); &#125; &#125; // 清空所有的内容 public static final void clear() &#123; w.lock(); try &#123; map.clear(); &#125; finally &#123; w.unlock(); &#125; &#125;&#125; 关于读写状态读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写 写锁的获取与释放写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。写锁的释放与ReentrantLock的释放过程基本类似，等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。 读锁的获取与释放读锁是一个支持重进入的共享锁，它能够被多个线程同时获取。读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。 锁降级锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。 锁降级示例：因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作。 123456789101112131415161718192021222324public void processData() &#123; readLock.lock(); if (!update) &#123; // 必须先释放读锁 readLock.unlock(); // 锁降级从写锁获取到开始 writeLock.lock(); try &#123; if (!update) &#123; // 准备数据的流程（略） update = true; &#125; readLock.lock(); &#125; finally &#123; writeLock.unlock(); &#125; // 锁降级完成，写锁降级为读锁 &#125; try &#123; // 使用数据的流程（略） &#125; finally &#123; readLock.unlock(); &#125; &#125; 当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。 锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。 RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。 ConditionAPI1234567void await() throws InterruptedException;void awaitUninterruptibly();long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;void signal();void signalAll(); await() 方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似； awaitUninterruptibly() 方法与 await() 方法基本相同，但是它并不会在等待过程中响应中断； singal() 用于唤醒一个在等待中的线程；singalAll() 方法会唤醒所有在等待中的线程，和Obejct.notify()方法很类似； 使用范式1234567891011121314151617Lock lock = new ReentrantLock();Condition condition = lock.newCondition();public void conditionWait() throws InterruptedException &#123; lock.lock(); try &#123; condition.await(); &#125; finally &#123; lock.unlock(); &#125;&#125; public void conditionSignal() throws InterruptedException &#123; lock.lock(); try &#123; condition.signal(); &#125; finally &#123; lock.unlock(); &#125; 官方示例范式中 lock() 并没有放在 try {} 中，应该是因为不排除获取锁(比如自定义锁)的过程中产生异常后，却调用了unlock() 方法。 和Object.wait()和notify()方法一样，当线程使用Condition.await()时，要求线程持有相关的重入锁，在Condition.await()调用后，这个线程会释放这把锁。 在Condition.signal()方法调用时，也要求线程先获得相关的锁。在signal()方法调用后，系统会从当前Condition对象的等待队列中，唤醒一个线程。一旦线程被唤醒，它会重新尝试获得与之绑定的重入锁，一旦成功获取，就可以继续执行了。因此，在signal()方法调用之后，一般需要释放相关的锁，谦让给被唤醒的线程，让它可以继续执行。 ArrayBlockingQueue 中 Lock 及 Condition 的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889final Object[] items;int takeIndex;int putIndex;int count;final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull;this.items = new Object[capacity];lock = new ReentrantLock(fair);notEmpty = lock.newCondition();notFull = lock.newCondition();public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125;private E dequeue() &#123; final Object[] items = this.items; E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; // 如果迭代器itrs不为null，则需要维护下该迭代器。可忽略 if (itrs != null) itrs.elementDequeued(); notFull.signal(); return x;&#125;public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; // while loop防止意外的通知，只有条件符合才能退出循环 while (count == items.length) notFull.await(); enqueue(e); &#125; finally &#123; lock.unlock(); &#125;&#125;private void enqueue(E x) &#123; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125;// 补充public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125;// 补充public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 实现分析ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。 等待队列等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。 一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。 Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。 在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。 await()调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。 await方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。 signal()signal()方法会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。 signal()方法的前置条件是当前线程必须获取了锁，会进行isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。被唤醒后的线程，会调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回。 Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。 LockSupport线程阻塞类工具，可以在线程内任何位置让线程阻塞。1. 和Thread.suspend()相比，它弥补了由于resume()在前发生，导致线程无法继续执行的情况。2. 和Object.wait()相比，它不需要先获得某个对象的锁。3. 也不会抛出InterruptedException异常。 LockSupport的静态方法park()可以阻塞当前线程，类似的还有parkNanos()、parkUntil()等方法，它们实现了一个限时的等待。 unpark(Thread thread)方法原来唤醒一个被阻塞的线程。 1234567891011121314151617181920212223242526272829public class LockSupportDemo &#123; public static Object u = new Object(); static ChangeObjectThread t1 = new ChangeObjectThread(\"t1\"); static ChangeObjectThread t2 = new ChangeObjectThread(\"t2\"); public static class ChangeObjectThread extends Thread &#123; public ChangeObjectThread(String name) &#123; super.setName(name); &#125; @Override public void run() &#123; synchronized (u) &#123; System.out.println(\"in \" + getName()); LockSupport.park(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; t1.start(); Thread.sleep(100); t2.start(); LockSupport.unpark(t1); LockSupport.unpark(t2); t1.join(); t2.join(); &#125;&#125; 虽然无法保证unpark()方法发生在park()方法之后。但以上代码自始至终都可以正常的结束，不会因为park()方法而导致线程永久性的挂起。这是因为LockSupport类使用类似信号量的机制。它为每一个线程准备了一个许可，如果许可可用，那么park()函数会立即返回，并且消费这个许可（也就是将许可变为不可用），如果许可不可用，就会阻塞。而unpark()则使得一个许可变为可用（但是和信号量不同的是，许可不能累加，你不可能拥有超过一个许可，它永远只有一个）。这个特点使得：即使unpark()操作发生在park()之前，它也可以使下一次的park()操作立即返回。 如果使用park(Object)函数，还可以为当前线程设置一个阻塞对象。这个阻塞对象会出现在线程Dump中。这样在分析问题时，就更加方便了。 LockSupport.park()还能支持中断影响。和其他接收中断的函数很不一样，LockSupport.park()不会抛出InterruptedException异常。它只是会默默的返回，我们可以从Thread.interrupted()等方法获得中断标记。 使用锁的最佳实践并发大师 Doug Lea《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践： 永远只在更新对象的成员变量时加锁 永远只在访问可变的成员变量时加锁 永远不在调用其他对象的方法时加锁 关于最后一条同样是尽量要去遵守：调用其他对象的方法，实在是太不安全了，也许其他方法里面有线程 sleep() 的调用，也可能会有奇慢无比的 I/O 操作，这些都会严重影响性能。更可怕的是，其他类的方法可能也会加锁，然后双重加锁就可能导致死锁。 CaseQ：下面的代码是否存在死锁？ A：不出现死锁，但会出现活锁（主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行）。 1234567891011121314151617181920212223class Account &#123; private int balance; private final Lock lock = new ReentrantLock(); // 转账 void transfer(Account tar, int amt)&#123; while (true) &#123; if(this.lock.tryLock()) &#123; try &#123; if (tar.lock.tryLock()) &#123; try &#123; this.balance -= amt; tar.balance += amt; &#125; finally &#123; tar.lock.unlock(); &#125; &#125;//if &#125; finally &#123; this.lock.unlock(); &#125; &#125;//if &#125;//while &#125;//transfer&#125; Reference《Java并发编程的艺术》 https://time.geekbang.org/column/article/87779","categories":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/categories/concurrent/"}],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"https://weilans.github.io/tags/concurrent/"}]},{"title":"[Leetcode单排] 单词接龙 (N127)","slug":"Leetcode单排-单词接龙-N127","date":"2019-08-01T13:46:54.000Z","updated":"2019-08-04T14:07:54.520Z","comments":true,"path":"2019/08/01/Leetcode单排-单词接龙-N127/","link":"","permalink":"https://weilans.github.io/2019/08/01/Leetcode单排-单词接龙-N127/","excerpt":"","text":"127. Word Ladderhttps://leetcode.com/problems/word-ladder/ 这道题目一眼看上去很像用 DFS 去操作，但是很快就会发现实在操作不下去。从单个单词跳往下一个单词时，还是得 26 个字符替换着来。这道题需要使用 BFS 完成，可以借助队列。从 beginWord 开始，对每个位置都尝试用26种字符替换，如果新字符串在单词集合中，则继续开始下一轮。需要注意的是，单词在集合中出现的话，需要将该单词删除，比如第 N + 2 轮出现的某个单词在第 N 轮也出现的话，那第 N 轮的分支得到的轮次数自然更少。 1234567891011121314151617181920212223242526272829303132333435public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (!wordList.contains(endWord)) &#123; return 0; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); int len = beginWord.length(); int step = 0; while (!queue.isEmpty()) &#123; ++step; // 对上一轮压进的所有值进行处理 for (int size = queue.size(); size &gt; 0; size--) &#123; String word = queue.poll(); // 针对String，获得其更改一位且在wordSet存在的值 for (int i = 0; i &lt; len; i++) &#123; for (char j = 'a'; j &lt; 'z'; j++) &#123; char[] arr = word.toCharArray(); arr[i] = j; String tempWord = new String(arr); if (endWord.equals(tempWord)) &#123; return step + 1; &#125; if (!wordSet.contains(tempWord)) &#123; continue; &#125; wordSet.remove(tempWord); queue.offer(tempWord); &#125; &#125; &#125; &#125; return 0;&#125; 广度优先搜索做出来已经比较不容易了，但是性能一般，还有另一种优化解法：双向广度优先搜索。单词数量较多时，效率相差非常明显。 Runtime: 14 ms, faster than 94.73%; Memory Usage: 38.1 MB, less than 99.36% 从一个队列换成两个 Set，一个从头到尾，一个从尾到头，每轮比较两个 Set 的大小，遍历小的一方的字符串进行处理，并将新单词 Set 赋给该 Set。后续继续比较两个 Set 的大小，以此类推。 12345678910111213141516171819202122232425262728293031323334353637383940414243public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (!wordList.contains(endWord)) &#123; return 0; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); Set&lt;String&gt; set1 = new HashSet&lt;&gt;(); set1.add(beginWord); Set&lt;String&gt; set2 = new HashSet&lt;&gt;(); set2.add(endWord); int len = beginWord.length(); int step = 0; while (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) &#123; step++; Set&lt;String&gt; tempSet = new HashSet&lt;&gt;(); boolean set1Big = set1.size() &gt; set2.size(); Set&lt;String&gt; smallSet = !set1Big ? set1 : set2; Set&lt;String&gt; bigSet = set1Big ? set1 : set2; for (String str : smallSet) &#123; for (int i = 0; i &lt; len; i++) &#123; for (char j = 'a'; j &lt; 'z'; j++) &#123; char[] arr = str.toCharArray(); arr[i] = j; String tempWord = new String(arr); if (bigSet.contains(tempWord)) &#123; return step + 1; &#125; if (!wordSet.contains(tempWord)) &#123; continue; &#125; wordSet.remove(tempWord); tempSet.add(tempWord); &#125; &#125; &#125; if (set1Big) &#123; set2 = tempSet; &#125; else &#123; set1 = tempSet; &#125; &#125; return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"bfs","slug":"bfs","permalink":"https://weilans.github.io/tags/bfs/"}]},{"title":"Clojure in Action: Clojure 构件","slug":"Clojure-in-Action-Clojure-构件","date":"2019-07-31T02:35:52.000Z","updated":"2019-08-12T02:36:37.813Z","comments":true,"path":"2019/07/31/Clojure-in-Action-Clojure-构件/","link":"","permalink":"https://weilans.github.io/2019/07/31/Clojure-in-Action-Clojure-构件/","excerpt":"","text":"元数据元数据提供了在必要时为值添加标识的 一种手段。 123456789101112131415161718192021222324252627282930(def untrusted (with-meta &#123;:command \"delete-table\" :subject \"users\"&#125; &#123;:safe false :io true&#125;)); 可以使用读取器宏^&#123;&#125;简化元数据定义(def untrusted ^&#123;:safe false :io true&#125; &#123;:command \"delete-table\" :subject \"users\"&#125;)untrusted;=&gt; &#123;:command \"delete-table\", :subject \"users\"&#125;;检查与值关联的元数据，可以使用meta函数(meta untrusted);=&gt; &#123;:safe false, :io true&#125;;元数据不影响值的相等性。(def trusted &#123;:command \"delete-table\" :subject \"users\"&#125;) (= trusted untrusted);=&gt; true;元数据在读取时可以加入，而不可以在求值时加入。下列程序将元数据与以hash-map开头的列表关联，而不是与函数调用产生的哈希映射关联，所以这个元数据在运行时不可见。(def untrusted2 ^&#123;:safe false :io true&#125; (hash-map :command \"delete-table\" :subject \"users\"))(meta untrusted2);=&gt; nil; 从有元数据的新值中创建新值时，元数据被复制到新数据里(def still-untrusted (assoc untrusted :complete? false))still-untrusted;=&gt; &#123;:complete? false, :command \"delete-table\", :subject \"users\"&#125;(meta still-untrusted);=&gt; &#123;:safe false, :io true&#125; 函数与宏也可以在定义中包含元数据。 1234567891011121314151617(defn ^&#123;:safe true :console true :doc \"testing metadata for functions\"&#125; testing-meta [] (println \"Hello from meta!\"))(meta testing-meta);=&gt; nil(meta (var testing-meta));=&gt; &#123;:ns #&lt;Namespace user&gt;,; :name testing-meta,; :file \"NO_SOURCE_FILE\",; :line 1, :arglists ([]),; :console true,; :safe true,; :doc \"testing metadata for functions\"&#125; Java 类型提示调用Java方法时，需要通过类找到方法的实现。但是，Clojure 是动态语言，变量类型只有在运行时才知道。可以使用读取器宏^symbol 123456789101112131415(set! *warn-on-reflection* true) ; Warn us when reflection is needed.(defn string-length [x] (.length x))(time (reduce + (map string-length (repeat 10000 \"12345\"))));Reflection warning;\"Elapsed time: 45.751 msecs\";=&gt; 50000(defn fast-string-length [^String x] (.length x)) ; No reflection warning.(time (reduce + (map fast-string-length (repeat 10000 \"12345\"))));\"Elapsed time: 5.788 msecs\";=&gt; 50000(meta (first (first (:arglists (meta #'fast-string-length)))))=&gt; &#123;:tag String&#125; Clojure 编译器在类型推导上相当智能，所有核心函数已经在必要时做了类型提示，所以不经常需要采用类型提示。 原始类型没有可读的类名可提供引用，Clojure 为所有原始类型和原始类型数组定义了别名：只需要使用^byte这样的类型提示表示原始类型，^bytes这样的复数形式表示原始类型数组。 Java 异常处理12345678910111213141516(defn average [numbers] (let [total (apply + numbers)] (/ total (count numbers))))(average []);ArithmeticException Divide by zero clojure.lang.Numbers.divide (Numbers.java:156)(defn safe-average [numbers] (let [total (apply + numbers)] (try (/ total (count numbers)) (catch ArithmeticException e (println \"Divided by zero!\") 0))))(safe-average []);Divided by zero!;=&gt; 0 如果有表达式产生异常，则 根据异常类型执行对应的 catch子句，返回该子句的值。可选的finally子句总会被执行，用于保证必须的副作用，但不返回任何数值。 1234567(try (print \"Attempting division... \") (/ 1 0) (finally (println \"done.\")))Attempting division... done.;=&gt;Execution error (ArithmeticException) at user/eval1516 (form-init4016394056826807004.clj:3).Divide by zero 需要注意catch子句的顺序。 12345678910(try (print \"Attempting division... \") (/ 1 0) (catch RuntimeException e \"Runtime exception!\") (catch ArithmeticException e \"DIVIDE BY ZERO!\") (catch Throwable e \"Unknown exception encountered!\") (finally (println \"done.\")));Attempting division... done.;=&gt; \"Runtime exception!\" 异常可以使用throw形式抛出，在希望抛出的场合可以使用: (throw (Exception. &quot;this is an error&quot;))。 函数先决和后置条件在执行函数主体之前运行的检查由:pre指定，称为先决条件。:post键指定的条件称为后置条件，条件中的%指的就是函数的返回值。 1234567891011121314151617181920(defn item-total [price quantity discount-percentage] &#123;:pre [(&gt; price 0) (&gt; quantity 0)] :post [(&gt; % 0)]&#125; (-&gt;&gt; (/ discount-percentage 100) (- 1) (* price quantity) float))(item-total 100 2 0);=&gt; 200.0(item-total 100 2 10);=&gt; 180.0(item-total 100 -2 10);Execution error (AssertionError) at user/item-total (form-init4016394056826807004.clj:1).;Assert failed: (&gt; quantity 0)(item-total 100 2 110);Execution error (AssertionError) at user/item-total (form-init4016394056826807004.clj:1).;Assert failed: (&gt; % 0) 重载（多种参数数量）12345(defn total-cost ([item-cost number-of-items] (* item-cost number-of-items)) ([item-cost] (total-cost item-cost 1))) 可以从某种参数数量的函数中调用其他参数数量的版本。 可变参数函数在 Clojure 中使用&amp;符号实现变长参数功能。 12(defn total-all-numbers [&amp; numbers] (apply + numbers)) 可变参数函数中有一些不可变的参数。可变参数中的必要参数数量至少要与最长的固定参数相同。 1234567891011121314151617(defn many-arities ([] 0) ([a] 1) ([a b c] 3) ([a b c &amp; more] \"variadic\"))(many-arities);=&gt; 0(many-arities \"one argument\");=&gt; 1(many-arities \"two\" \"arguments\");Execution error (ArityException) at user/eval1554 (form-init4016394056826807004.clj:11).;Wrong number of args (2) passed to: user/many-arities(many-arities \"three\" \"argu-\" \"ments\");=&gt; 3(many-arities \"many\" \"more\" \"argu-\" \"ments\");=&gt; \"variadic\" 高阶参数every?接受一个返回布尔值的函数（判定函数）和一个序列 12345(def bools [true true true false false])(every? true? bools) ;=&gt; false(every? even? '(2 4 6));=&gt; true some接受一个判定和一个序列，返回获得的第一个逻辑true值，如果调用都不返回逻辑 true，则返回 nil。 12(some (fn [p] (= \"rob\" p)) [\"kyle\" \"siva\" \"rob\" \"celeste\"]);=&gt; true constantly接受一个值 v，返回一个可变参数函数，这个函数不管输入的参数为何，总是返回相同的值 v。 12345678(def two (constantly 2)) ; same as ;(def two (fn [&amp; more] 2));(defn two [&amp; more] 2);=&gt; #'clj-in-act.ch3/two(two 1);=&gt; 2(two :a :b :c);=&gt; 2 complement接受一个函数作为参数，返回与原始函数参数数量相同、完成相同工作但返回逻辑相反值的函数。 123456789101112(defn greater? [x y] (&gt; x y))(greater? 10 5);=&gt; true(greater? 10 20);=&gt; false(def smaller? (complement greater?))(smaller? 10 5);=&gt; false(smaller? 10 20);=&gt; true comp接受多个函数并返回由哪些函数组合而成的新函数。计算从右到左进行，新函数将其参数应用于原始组成函数中最右侧的一个，然后将结果应用到它左边的函数，直到所有函数都被调用。 1234567(def opp-zero-str (comp str not zero?)); (defn opp-zero-str [x] (str (not (zero? x))))(opp-zero-str 0);=&gt; \"false\"(opp-zero-str 1);=&gt; \"true\" partial接受函数 f 以及 f 的几个参数，然后partial返回一个新函数，接受 f 的其余参数。当以余下的参数调用新函数时，它以全部参数调用原始函数 f。 1234567(defn above-threshold? [threshold number] (&gt; number threshold))(filter (fn [x] (above-threshold? 5 x)) [1 2 3 4 5 6 7 8 9]);=&gt; (6 7 8 9)(filter (partial above-threshold? 5) [1 2 3 4 5 6 7 8 9]);=&gt; (6 7 8 9) memoize内存化可以避免函数为已处理过的参数计算结果。 1234567891011121314(defn slow-calc [n m] (Thread/sleep 1000) (* n m))(time (slow-calc 5 7));\"Elapsed time: 1000.097 msecs\";=&gt; 35(def fast-calc (memoize slow-calc))(time (fast-calc 5 7));\"Elapsed time: 1002.446198 msecs\";=&gt; 35(time (fast-calc 5 7));\"Elapsed time: 0.089624 msecs\";=&gt; 35 注意：memoize缓存没有限定大小，因而会不停缓存输入和结果。因此该函数只应该用于少量可能输入的函数，否则最终会把内存耗尽。更高级的内存化功能，可以使用clojure.core.memoize库。 匿名函数匿名函数使用fn创建。 123(defn sorter-using [ordering-fn] (fn [collection] (sort-by ordering-fn collection))) 同时可以使用#()创建一个匿名函数。%表示一个参数，如果超过一个参数，则可以使用%1、%2…还可以使用%&amp;表示除明确引用的%&amp;参数之外的参数。 12345678(#(vector %&amp;) 1 2 3 4 5);=&gt; [(1 2 3 4 5)](#(vector % %&amp;) 1 2 3 4 5);=&gt; [1 (2 3 4 5)](#(vector %1 %2 %&amp;) 1 2 3 4 5);=&gt; [1 2 (3 4 5)](#(vector %1 %2 %&amp;) 1 2);=&gt; [1 2 nil]","categories":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/categories/clojure/"}],"tags":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/tags/clojure/"}]},{"title":"[Leetcode单排] 单词搜索 (N79 N212)","slug":"Leetcode单排-单词搜索 (N79 N211)","date":"2019-07-30T12:56:39.000Z","updated":"2019-07-31T15:37:04.885Z","comments":true,"path":"2019/07/30/Leetcode单排-单词搜索 (N79 N211)/","link":"","permalink":"https://weilans.github.io/2019/07/30/Leetcode单排-单词搜索 (N79 N211)/","excerpt":"","text":"79. Word Searchhttps://leetcode-cn.com/problems/word-search/ 在二维数组中搜索具体的单词是否存在。这个题目有几个值得借鉴吸收的地方： 1、 当要在二维数组的特定点四周继续寻找时，不需要写函数计算这个点周围有几个可用点，可以直接在递归中判断是否 out of range； 2、要注意递归函数的具体功能含义。初始尝试时，找到开始点和递归方法写成了两个函数，实际上可以融合； 3、下面的做法没有采用单独的列表存储走过的元素，而是采用将值记录为0，这样就可以在递归中碰到这个点时必然不相等，就相当于排除了这个点。 123456789101112131415161718192021222324252627282930public boolean exist(char[][] board, String word) &#123; for (int i = 0; i &lt; board[0].length; i++) &#123; for (int j = 0; j &lt; board.length; j++) &#123; if (dfs(i, j, 0, word, board)) &#123; return true; &#125; &#125; &#125; return false;&#125;private boolean dfs(int x, int y, int i, String word, char[][] board) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= board[0].length || y &gt;= board.length) &#123; return false; &#125; if (board[y][x] != word.charAt(i)) &#123; return false; &#125; if (i == word.length() - 1) &#123; return true; &#125; char temp = board[y][x]; board[y][x] = '0'; boolean res = dfs(x + 1, y, i + 1, word, board) || dfs(x - 1, y, i + 1, word, board) || dfs(x, y + 1, i + 1, word, board) || dfs(x, y - 1, i + 1, word, board); board[y][x] = temp; return res;&#125; 下面这个是使用了访问变量的版本： 123456789101112131415161718192021222324252627282930313233public boolean exist(char[][] board, String word) &#123; boolean[][] visit = new boolean[board.length][]; for (int i = 0; i &lt; board.length; i++) &#123; visit[i] = new boolean[board[0].length]; &#125; for (int i = 0; i &lt; board[0].length; i++) &#123; for (int j = 0; j &lt; board.length; j++) &#123; if (dfs(i, j, 0, word, board, visit)) &#123; return true; &#125; &#125; &#125; return false;&#125;private boolean dfs(int x, int y, int i, String word, char[][] board, boolean[][] visit) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= board[0].length || y &gt;= board.length) &#123; return false; &#125; if (board[y][x] != word.charAt(i) || visit[y][x]) &#123; return false; &#125; if (i == word.length() - 1) &#123; return true; &#125; visit[y][x] = true; boolean res = dfs(x + 1, y, i + 1, word, board, visit) || dfs(x - 1, y, i + 1, word, board, visit) || dfs(x, y + 1, i + 1, word, board, visit) || dfs(x, y - 1, i + 1, word, board, visit); visit[y][x] = false; return res;&#125; 212. Word Search IIhttps://leetcode.com/problems/word-search-ii/ 与上题不同的是，这次是给一个字符串数组，结果是所有满足条件的字符串的集合，其实就是把上题中的单字符串换成字符串数组。如果基于上文中的解法直接加一层for循环：Your runtime beats 13.43 %, memory usage beats 90.76 %。 正确做法是基于 Trie 树，其实从一串字符串中进行筛选就应该想到使用前缀树。答案借鉴的这位的做法，这代码风格和我上一题基本一模一样。实际上需要以二维数组的每个字符去匹配 Trie 树，从顶向下找，看能包含几个字符串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 构建Trie树节点(26叉树)class TrieNode &#123; public TrieNode[] children = new TrieNode[26]; public String word = null;&#125;// 构建Trie树class Trie &#123; public TrieNode root = new TrieNode(); // 只需要插入方法即可 public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); ++i) &#123; int charNo = word.charAt(i) - 'a'; if (node.children[charNo] == null) &#123; node.children[charNo] = new TrieNode(); &#125; node = node.children[charNo]; &#125; node.word = word; &#125;&#125;public class Solution &#123; public List&lt;String&gt; findWords(char[][] board, String[] words) &#123; // 事先构造 Trie trie = new Trie(); for (String word : words) &#123; trie.insert(word); &#125; boolean[][] visited = new boolean[board.length][board[0].length]; Set&lt;String&gt; resultSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; board.length; ++i) &#123; for (int j = 0; j &lt; board[0].length; ++j) &#123; search(board, visited, i, j, board.length, board[0].length, trie.root, resultSet); &#125; &#125; return new ArrayList&lt;&gt;(resultSet); &#125; private void search(char[][] board, boolean[][] visit, int i, int j, int x, int y, TrieNode node, Set&lt;String&gt; result) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= x || j &gt;= y || visit[i][j]) &#123; return; &#125; node = node.children[board[i][j] - 'a']; if (node == null) &#123; return; &#125; if (node.word != null) &#123; result.add(node.word); // 此处没有 return，后续可能还存在字符串 &#125; visit[i][j] = true; search(board, visit, i - 1, j, x, y, node, result); search(board, visit, i + 1, j, x, y, node, result); search(board, visit, i, j - 1, x, y, node, result); search(board, visit, i, j + 1, x, y, node, result); visit[i][j] = false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"Clojure in Action: 程序结构、程序流程","slug":"Clojure-in-Action-程序结构、程序流程","date":"2019-07-30T05:58:29.000Z","updated":"2019-07-30T12:40:51.548Z","comments":true,"path":"2019/07/30/Clojure-in-Action-程序结构、程序流程/","link":"","permalink":"https://weilans.github.io/2019/07/30/Clojure-in-Action-程序结构、程序流程/","excerpt":"","text":"程序结构函数定义defn宏展开为def和fn调用的组合。fn宏接受方括号中的一系列参数然后是程序主体，fn形式可以用于定义匿名函数。 1234567(defn addition-function [x y] (+ x y));; Expanded form:(def addition-function (fn [x y] (+ x y))) let 形式let形式接受一个向量作为其第一个参数，该向量包含偶数个形式，然后是在 let 求值时进行求值的 0 个或者多个形式。let 形式可以在代码中将一个符号和某个值绑定，从而引入局部命名对象。let 返回的是最后一个表达式的值。 12345(let [x 1 y 2 z (+ x y)] z);=&gt; 3 以下函数可以使用 let 将其分成几个部分，使代码清晰。 123456789(defn average-pets [] (/ (apply + (map :number-pets (vals users))) (count users))) (defn average-pets [] (let [user-data (vals users) pet-counts (map :number-pets user-data) total (apply + pet-counts)] (/ total (count users)))) 在 let 中如果不需要关注值，可以使用下划线标识符，下划线标识符本身没有什么特别之处，只是 clojure 的一个惯例。在解构中，下划线标识符更加实用：(let [[_ _ z] [1 2 3]] z)。 123456(defn average-pets [] (let [user-data (vals users) pet-counts (map :number-pets user-data) _ (println \"total pets:\" pet-counts) total (apply + pet-counts)] (/ total (count users)))) do纯函数语言中，程序是没有副作用的，函数的唯一行为就是计算一个值并返回。但是现实世界中必然充满了状态，也必然有副作用，例如向控制台或者日志文件中打印某些内容、在数据库中保存内容就是改变世界状态的副作用。为了将多个表达式转为一个形式，clojure 提供了 do形式。 12345(if (is-something-true?) (do (log-message \"in true branch\") (store-something-in-db) (return-useful-value))) 1(for [i (range 1 3)] (do (println i) i)) 程序流程条件if(if test consequent alternative) if形式接受一个测试表达式，若为真则求后续表达式(consequent)，若为假则则使用替代形式(alternative)。形式可以结合do形式使其完成多项工作。 12(if (&gt; 5 2) \"yes\" \"no\");=&gt; \"yes\" if-not12(if-not (&gt; 5 2) \"yes\" \"no\");=&gt; \"no\" condcond可以将嵌套的if条件数扁平化，(cond &amp; clauses)。 123456(def x 1)(cond (&gt; x 0) \"greater!\" (= x 0) \"zero!\" :default \"lesser!\");=&gt; \"greater!\" 子句（clauses）是成对的表达式。当一个表达式返回 true，求值相关的后续表达式并返回。 如果所有表达式都没有返回真值，则可以传入取真值的表达式（比如关键词 :default），然后求值相关的后续表达式并返回。 whenwhen宏是将一个if和一个隐式的do。 123456789(when (&gt; 5 2) (println \"five\") (println \"is\") (println \"greater\") \"done\");five;is;greater;=&gt; \"done\" 此处就没有必要将do包装这三个函数了，when宏会负责这项工作。 when-not123456789(when-not (&lt; 5 2) (println \"two\") (println \"is\") (println \"smaller\") \"done\");two;is;smaller;=&gt; \"done\" 逻辑函数and接受 0 个或多个形式，按顺序求值每个形式，如果任何一个返回 nil 或者 false，则返回该值。如果所有形式都不返回 false 或 nil，则 and 返回最后一个形式的值。如果没有任何值，则返回 true。 12345678910(and);=&gt; true(and :a :b :c);=&gt; :c(and :a nil :c);=&gt; nil(and :a false :c);=&gt; false(and 0 \"\");=&gt; \"\" or接受 0 个或多个形式并逐一求值，如果任何形式返回逻辑真值，则将该值返回。如果所有形式都不返回逻辑真值，则返回最后一个值。 12345678910(or);=&gt; nil(or :a :b :c);=&gt; :a(or :a nil :c);=&gt; :a(or nil false);=&gt; false(or false nil);=&gt; nil not该函数始终返回true或者false。 123456(not true);=&gt; false(not 1);=&gt; false(not nil);=&gt; true 比较函数&lt;、&lt;=、&gt;、&gt;=、=有一个额外特性：可以取任意数量的参数。 12345; &lt; 可检测是否以升序排列(&lt; 2 4 6 8);=&gt; true(&lt; 2 4 3 8);=&gt; false = 与 ===函数等同于 Java 的 equals，但适用于范围更广的对象，包括 nil、数值、序列。Clojure 中的 ==函数只能用于比较数值。=可以比较任意两个值，但比较三种不同类型的数值时结果不理想。 12345678(= 1 1N 1/1);=&gt; true(= 0.5 1/2);=&gt; false(= 0.5M 0.5);=&gt; false(= 0.5M 1/2);=&gt; false 如果对比不同类型的数值，则可以用==代替，但是所有参数必须是数值。 12345678910111213(== 1 1N 1/1);=&gt; true(== 1/2 0.5M 0.5);=&gt; true1.9999999999999999;=&gt; 2.0(== 2.0M 1.9999999999999999) ; == 不是对抗浮点精度和舍入问题的银弹;=&gt; true_(== :a 1);ClassCastException clojure.lang.Keyword cannot be cast to java.lang.Number clojure.lang.Numbers.equiv (Numbers.java:206)_(== nil 1);NullPointerException clojure.lang.Numbers.ops (Numbers.java:961) 如果你预计所有要对比的数据都是数值，且预期有不同类型的数字，则使用==，否则使用=。 函数式循环大部分函数式语言都不支持传统的for循环结构，因为for的典型实现需要改变循环计数器的值。作为替代，它们使用递归和函数应用。 whilewhile宏与命令式语言类似。 12(while (request-on-queue?) (handle-request (pop-request-queue))) loop/recurClojure 没有传统的for循环，其循环流程控制是使用loop和recur。 12345(defn fact-loop [n] (loop [current n fact 1] (if (= current 1) fact (recur (dec current) (* fact current) )))) loop建立和let形式完全相同的绑定，recur也有两个绑定值(def current)和(* fact current)，他们在计算之后重新与current和fact绑定。 recur看起来像递归，实际上不适用栈。recur仅能作用于代码尾部，如果企图从任何其他位置使用它，编译器会报错。 doseq 和 dotimes123456(defn run-report [user] (println \"Running report for\" user))(defn dispatch-reporting-jobs [all-users] (doseq [user all-users] (run-report user))) 上面这个例子中doseq的第一个项是一个新符号，以后将绑定到第二个项（必须是一个序列）中的每一个元素。形式的主体将对序列中的每个元素执行，然后整个形式将返回 nil。 dotimes与之类似，接受一个向量（包含一个符号和一个数值），向量中符号被设置为 0 到 (n-1) 的值，并对每个数值求取主体的值。 12(dotimes [x 5] (println \"X is\" x)) 将打印数字 0~4，返回 nil。 map 、filter、remove、reduce、for在前篇文章中的数据结构 — 序列中的“序列转换”一节中已提及。这里做一些补充。 map 12345678910(map inc [0 1 2 3]);=&gt; (1 2 3 4);; map 接受一个函数，其可以有任意多个参数以及相同数量的序列。每个序列为函数提供一个参数。(map + [0 1 2 3] [0 1 2 3]);=&gt; (0 2 4 6);; 返回值的长度等于最短序列的长度(map + [0 1 2 3] [0 1 2]);=&gt; (0 2 4) filter 12345(defn non-zero-expenses [expenses] (let [non-zero? (fn [e] (not (zero? e)))] (filter non-zero? expenses)))(non-zero-expenses [-2 -1 0 1 2 3]);=&gt; (-2 -1 1 2 3) remove filter判定保留哪些元素，remove判定抛弃哪些元素。两者刚好相反。 1234(defn non-zero-expenses [expenses] (remove zero? expenses))(non-zero-expenses [-2 -1 0 1 2 3]);=&gt; (-2 -1 1 2 3) reduce &amp; reductions reduce接受一个函数（有两个参数）和一个数据元素序列。函数参数应用到序列的前两个元素，产生第一个结果，之后使用这个结果和序列的下一个元素再次调用同一个函数。重复此过程直到处理完最后一个元素。 12345(defn factorial [n] (let [numbers (range 1 (+ n 1))] (reduce * numbers)))(factorial 5);=&gt; 120 reduce只返回最终的规约值，而reductions返回每个中间值组成的序列。 12345(defn factorial-steps [n] (let [numbers (range 1 (+ n 1))] (reductions * numbers)))(factorial-steps 5);=&gt; (1 2 6 24 120) for 可以使用的限定词：:let，:when，:while 123456789101112(for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y);=&gt; (0 6 12)(def chessboard-labels (for [alpha \"abcdefgh\" num (range 1 9)] (str alpha num)))chessboard-labels;=&gt; (\"a1\" \"a2\" \"a3\" \"a4\" \"a5\" … \"h6\" \"h7\" \"h8\") 123456789101112131415161718(defn prime? [x] (let [divisors (range 2 (inc (int (Math/sqrt x)))) remainders (map (fn [d] (rem x d)) divisors)] (not (some zero? remainders))))(defn primes-less-than [n] (for [x (range 2 (inc n)) :when (prime? x)] x))(primes-less-than 50);=&gt; (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)(defn pairs-for-primes [n] (let [z (range 2 (inc n))] (for [x z y z :when (prime? (+ x y))] (list x y))))(pairs-for-primes 5);=&gt; ((2 3) (2 5) (3 2) (3 4) (4 3) (5 2)) 串行宏thread-first12(defn final-amount [principle rate time-periods] (* (Math/pow (+ 1 (/ rate 100)) time-periods) principle)) 以上函数定义不易理解，需要从里往外读。使用thread-first宏-&gt;改写如下。该宏所做的是取第一个参数，将其放在下一个表达式的第二个位置。之所以成为thread-first，是因为它将代码移到下一个形式首个参数的位置。之后，它取得整个结果表达式，并将其移到再下一个表达式的第二个位置。 123456(defn final-amount-&gt; [principle rate time-periods] (-&gt; rate (/ 100) (+ 1) (Math/pow time-periods) (* principle))) thread-lastthread-last宏-&gt;&gt;在取得第一个表达式结果后，将其移入下一个表达式最后的位置。之后，对所有表达式重复该 过程。 12345678(defn factorial [n] (reduce * (range 1 (+ 1 n))))(defn factorial-&gt;&gt; [n] (-&gt;&gt; n (+ 1) (range 1) (reduce *))) thread-last宏更常见的用途是处理数据元素序列以及使用 map、reduce、filter 这样的高阶函数。这些函数都接受序列作为最后一个元素，所以thread-last宏更为合适。 some-&gt;和some-&gt;&gt;和上述两个宏基本相同，但是如果表达式的任意一步的结果是 nil，则计算结束。 thread-asthread-as宏as-&gt;相比上两者，更加灵活：你为它提供一个名称，它将把各个连续形式的结果绑定到这个名称，以便下一步使用。 1234(as-&gt; &#123;\"a\" [1 2 3 4]&#125; &lt;&gt; (&lt;&gt; \"a\") (conj &lt;&gt; 10) (map inc &lt;&gt;)) 该例子展开后如下： 12345(let [&lt;&gt; &#123;\"a\" [1 2 3 4]&#125; &lt;&gt; (&lt;&gt; \"a\") &lt;&gt; (conj &lt;&gt; 10) &lt;&gt; (map inc &lt;&gt;)] &lt;&gt;) 条件式串行宏cond-&gt;和cond-&gt;&gt;除了每个形式都包含一个条件之外，和-&gt;以及-&gt;&gt;基本相同，如果一个条件为false，则对应的形式将会跳过，但是对下一对形式继续串行求值（cond则是在发现为真的判定后将立刻停止后续成对形式的求值，而cond-&gt;会对每个条件求值）。 123456(let [x 1 y 2] (cond-&gt; [] (odd? x) (conj \"x is odd\") (zero? (rem y 3)) (conj \"y is divisible by 3\") (even? y) (conj \"y is even\")));=&gt; [\"x is odd\" \"y is even\"] 其等价描述为： 123456(let [x 1 y 2] (as-&gt; [] &lt;&gt; (if (odd? x) (conj &lt;&gt; \"x is odd\") &lt;&gt;) (if (zero? (rem y 3)) (conj &lt;&gt; \"y is divisible by 3\") &lt;&gt;) (if (even? y) (conj &lt;&gt; \"y is even\") &lt;&gt;)));=&gt; [\"x is odd\" \"y is even\"]","categories":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/categories/clojure/"}],"tags":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/tags/clojure/"}]},{"title":"Java进程CPU高负载排查","slug":"Java进程CPU高负载排查","date":"2019-07-30T03:39:55.000Z","updated":"2019-07-30T12:53:28.344Z","comments":true,"path":"2019/07/30/Java进程CPU高负载排查/","link":"","permalink":"https://weilans.github.io/2019/07/30/Java进程CPU高负载排查/","excerpt":"","text":"Arthas 排查怕麻烦的话，直接使用Arthas排查，具体的线程排查命令可以使用：thread -n 3，表示当前最忙的前N个线程并打印堆栈（详细命令）。 123wget https://alibaba.github.io/arthas/arthas-boot.jarjava -jar arthas-boot.jar &lt;pid&gt;thread -n 3 jstack 排查 使用top将系统资源实时显示，输入大写P对CPU消耗进行排序，第一个就是CPU消耗最高的程序，获取 pid （或者也可以使用jps找到特定程序 pid）。 利用top -Hp pid（-H表示开启线程查看），之后输入大写P，按照CPU使用率对线程排序。 找出线程ID后转为16进制:printf &quot;%x\\n&quot; tid。 通过jstack pid &gt; jstack.log生成进程日志文件，在文件中搜索16进制的线程ID，就可以看到这个线程在干啥了。","categories":[{"name":"java","slug":"java","permalink":"https://weilans.github.io/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://weilans.github.io/tags/jvm/"}]},{"title":"[Leetcode单排] 括号生成 (N22)","slug":"Leetcode单排-括号生成-N22","date":"2019-07-29T11:48:30.000Z","updated":"2019-07-29T12:16:18.215Z","comments":true,"path":"2019/07/29/Leetcode单排-括号生成-N22/","link":"","permalink":"https://weilans.github.io/2019/07/29/Leetcode单排-括号生成-N22/","excerpt":"","text":"22. Generate Parentheseshttps://leetcode.com/problems/generate-parentheses/ 给出一个整数 n，给出 n 对左右括号所有可能的排列结果。 设左右括号的个数分别为left和right，则需要满足以下规律：left &lt;= n &amp;&amp; right &lt;= right。所以在每一次递归中需要考虑两种变量的变化。以 left = 2, right = 0为例， 满足第一个条件，则求解handle(3,3,0,&quot;(((&quot;, result)分支下所有满足条件的情况，之后再考虑handle(3,2,1,&quot;(()&quot;, result)分支下所有满足条件结果。两个情况只要满足条件都要进行。 答案虽然比较短，但还是需要仔细咀嚼。 123456789101112131415161718192021public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (n &lt;= 0) &#123; return result; &#125; handle(n, 0, 0, \"\", result); return result;&#125;private void handle(int n, int left, int right, String cur, List&lt;String&gt; result) &#123; if (left == n &amp;&amp; right == n) &#123; result.add(cur); return; &#125; if (left &lt; n) &#123; handle(n, left + 1, right, cur + \"(\", result); &#125; if (right &lt; left) &#123; handle(n, left, right + 1, cur + \")\", result); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"[Leetcode单排] 数独 (N37)","slug":"Leetcode单排-数独-N37","date":"2019-07-28T16:55:31.000Z","updated":"2019-07-28T17:50:08.405Z","comments":true,"path":"2019/07/29/Leetcode单排-数独-N37/","link":"","permalink":"https://weilans.github.io/2019/07/29/Leetcode单排-数独-N37/","excerpt":"","text":"37. Sudoku Solverhttps://leetcode.com/problems/sudoku-solver/ 这道题目你知道是回溯，知道是DFS，但是如果需要你完整的做出来，你会发现还是有各种各样的问题。下面这个做法来源于花花酱的讲解。 N皇后是每次递归是确定一行一列，但是这个题目你会发现连每个单元格都可能有N种可能，所以递归的时候不是定住行和列，而是以单元格进行递归。访问变量也从一维变成了两位。比如rows boolean[i][j]就是指第 i 行值为 j 的数是否已存在，而boxes[i][j]就是在第 i 个九宫格值为 j 的数是否已存在。 输入里面已经包含部分数值，所以开局先填充一波访问变量，之后正式开始递归。递归函数 fill的返回值是布尔类型，代表 x 和 y 确定时，board中的位置是否有满足条件的情况。在 for 循环里面只要有一个满足了条件则立刻结束。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849boolean[][] rows = new boolean[9][10];boolean[][] cols = new boolean[9][10];boolean[][] boxes = new boolean[9][10];public void solveSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char c = board[i][j]; if (c != '.') &#123; int n = c - '0'; int bx = j / 3; int by = i / 3; rows[i][n] = true; cols[j][n] = true; boxes[by * 3 + bx][n] = true; &#125; &#125; &#125; fill(board, 0, 0);&#125;private boolean fill(char[][] board, int x, int y) &#123; if (y == 9) &#123; return true; &#125; int nextX = (x + 1) % 9; int nextY = (nextX == 0) ? y + 1 : y; if (board[y][x] != '.') &#123; return fill(board, nextX, nextY); &#125; // 每个单元格以 1-9 去试 for (int i = 1; i &lt;= 9; i++) &#123; int boxIndex = y / 3 * 3 + x /3; if (!rows[y][i] &amp;&amp; !cols[x][i] &amp;&amp; !boxes[boxIndex][i]) &#123; rows[y][i] = true; cols[x][i] = true; boxes[boxIndex][i] = true; board[y][x] = (char)(i + '0'); if (fill(board, nextX, nextY)) &#123; return true; &#125; board[y][x] = '.'; rows[y][i] = false; cols[x][i] = false; boxes[boxIndex][i] = false; &#125; &#125; return false;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"[Leetcode单排] N皇后 (N51 N52)","slug":"Leetcode单排-N皇后-N51-N52","date":"2019-07-28T12:58:36.000Z","updated":"2019-07-28T14:02:50.673Z","comments":true,"path":"2019/07/28/Leetcode单排-N皇后-N51-N52/","link":"","permalink":"https://weilans.github.io/2019/07/28/Leetcode单排-N皇后-N51-N52/","excerpt":"","text":"51. N-Queenshttps://leetcode.com/problems/n-queens/ N皇后问题，这里是将花花的讲解翻成 Java 版，花花的讲解已足够简明易懂。 每个棋子在每一行每一列必须是唯一的，这倒还好，关键在于每个棋子的所在斜线和反斜线都不包含棋子。难点就在于如何确认斜线处是否有棋子。而在标准做法中，斜线和反斜线各需要一个布尔数组就可以做到，只要找到 x 及 y 下标关系即可。 从第 0 行开始，确定第 0 行 Q 所在位置，之后递归行数加 1，以此类推。 因为担心递归函数中包含变量太多，故将三个布尔数组作为了全局变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758boolean[] cols;boolean[] diag1;boolean[] diag2;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; if (n &lt;= 0) &#123; return null; &#125; cols = new boolean[n]; // 左下-右上斜线 idx = x + y diag1 = new boolean[2 * n - 1]; // 左上-右下斜线 idx = x - y + (n -1) diag2 = new boolean[2 * n - 1]; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; initial = buildInitialList(n); handle(n, 0, initial, result); return result;&#125;private void handle(int n, int row, List&lt;String&gt; cur, List&lt;List&lt;String&gt;&gt; result) &#123; if (row == n) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int j = 0; j &lt; n; j++) &#123; if (available(j, row, n)) &#123; update(j, row, n, true, cur); handle(n, row + 1, cur, result); update(j, row, n, false, cur); &#125; &#125;&#125;private boolean available(int x, int y, int n) &#123; return !(cols[x] || diag1[x + y] || diag2[x - y + (n - 1)]);&#125;private void update(int x, int y, int n, boolean state, List&lt;String&gt; cur) &#123; cols[x] = state; diag1[x + y] = state; diag2[x - y + (n - 1)] = state; char[] rowArray = cur.get(y).toCharArray(); rowArray[x] = state ? 'Q' : '.'; cur.set(y, new String(rowArray));&#125;private List&lt;String&gt; buildInitialList(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; n; j++) &#123; sb.append('.'); &#125; res.add(sb.toString()); &#125; return res;&#125; 52. N-Queens IIhttps://leetcode.com/problems/n-queens-ii/ 52题和51题是一样的，只是这次是计算个数。这里是将 count 作为全局变量，其实可以将 handle 返回 count，亦或者 handle 在每次满足条件时返回 1，这几种做法皆可。（只要不是犯将 count 放到参数这种低级错误皆可）。 左程云的书 里面还有一种使用位运算做加速的超自然做法，暂且备注一下。 1234567891011121314151617181920212223242526272829303132int count = 0;public int totalNQueens(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; handle(0, n, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1]); return count;&#125;private void handle(int row, int n, boolean[] cols, boolean[] diag1, boolean[] diag2) &#123; if (row == n) &#123; ++count; &#125; for (int j = 0; j &lt; n; j++) &#123; if (available(j, row, n, cols, diag1, diag2)) &#123; modifyState(j, row, n, cols, diag1, diag2, true); handle(row + 1, n, cols, diag1, diag2); modifyState(j, row, n, cols, diag1, diag2, false); &#125; &#125;&#125;private boolean available(int x, int y, int n, boolean[] cols, boolean[] diag1, boolean[] diag2) &#123; return !(cols[x] || diag1[x + y] || diag2[x - y + (n - 1)]);&#125;private void modifyState(int x, int y, int n, boolean[] cols, boolean[] diag1, boolean[] diag2, boolean state) &#123; cols[x] = state; diag1[x + y] = state; diag2[x - y + (n - 1)] = state;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"[Leetcode单排] Subsets (N78 N90)","slug":"Leetcode单排-Subsets-N78-N90","date":"2019-07-27T15:10:06.000Z","updated":"2019-07-28T14:03:24.713Z","comments":true,"path":"2019/07/27/Leetcode单排-Subsets-N78-N90/","link":"","permalink":"https://weilans.github.io/2019/07/27/Leetcode单排-Subsets-N78-N90/","excerpt":"","text":"78. Subsetshttps://leetcode.com/problems/subsets/ 这两道取子集的题目基本上也没什么好讲的，基本的回溯方法即可，处理方式同排列和组合系列。 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(nums, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int[] nums, int start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(cur)); for (int i = start; i &lt; nums.length; i++) &#123; cur.add(nums[i]); // 注意别写成 start + 1 handle(nums, i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 90. Subsets IIhttps://leetcode.com/problems/subsets-ii/ 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); handle(nums, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int[] nums, int start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(cur)); for (int i = start; i &lt; nums.length; i++) &#123; // 与 N40 中 for 循环里的 if 判断如出一辙 if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.add(nums[i]); handle(nums, i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"[Leetcode单排] Letter Combinations of a Phone Number(N17)","slug":"Leetcode单排-Letter-Combinations-of-a-Phone-Number (N17)","date":"2019-07-26T06:59:38.000Z","updated":"2019-07-28T14:04:00.360Z","comments":true,"path":"2019/07/26/Leetcode单排-Letter-Combinations-of-a-Phone-Number (N17)/","link":"","permalink":"https://weilans.github.io/2019/07/26/Leetcode单排-Letter-Combinations-of-a-Phone-Number (N17)/","excerpt":"","text":"17.Letter Combinations of a Phone Numberhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/ 每个号码对应3或4个数字，输入一组号码，打印所有可能出现的排列。这道题很明显有BFS和DFS两类做法。 解法一当处理第n个数字时，实际上就是以n-1次的处理结果加上第n个数字对应的几个字符进行处理。 123456789101112131415161718192021/** * BFS 多层loop */public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; String digitArr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); result.add(\"\"); for (int i = 0; i &lt; digits.length(); i++) &#123; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); for (String str : result) &#123; for (char c : digitArr[digits.charAt(i) - '0'].toCharArray()) &#123; temp.add(str + c); &#125; &#125; result = temp; &#125; return result;&#125; 在答案中看到另一种BFS的做法，他是以一个Queue作为载体。这种做法很巧妙，但是在写 while 和 for 中条件时还是比较容易出错的。 123456789101112131415161718/** * BFS 使用queue，易错点在于while条件以及for中数组的获取 */public List&lt;String&gt; letterCombinations2(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; String digitArr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;(); result.add(\"\"); while (result.peek().length() != digits.length()) &#123; String peek = result.remove(); for (char c : digitArr[digits.charAt(peek.length()) - '0'].toCharArray()) &#123; result.add(peek + c); &#125; &#125; return result;&#125; 解法二在DFS中，表示当前结果的 String cur，在每次递归中都是一个新的String。一般在DFS的递归之后需要对表示当前结果的值进行回滚，而在这种场景下则不需要。 12345678910111213141516171819202122/** * DFS 递归 */public List&lt;String&gt; letterCombinations3(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; String digitArr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); dfs(digits, digitArr, 0, \"\", result); return result;&#125;private void dfs(String digits, String[] digitArr, int i, String cur, List&lt;String&gt; result) &#123; if (i == digits.length()) &#123; result.add(cur); return; &#125; for (char c : digitArr[digits.charAt(i) - '0'].toCharArray()) &#123; dfs(digits, digitArr, i + 1, cur + c, result); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"bfs","slug":"bfs","permalink":"https://weilans.github.io/tags/bfs/"}]},{"title":"[Leetcode单排] 组合系列 (N39 N40 N77 N216)","slug":"Leetcode单排- 组合系列 (N39 N40 N77 N216)","date":"2019-07-25T14:18:06.000Z","updated":"2019-07-28T14:02:45.857Z","comments":true,"path":"2019/07/25/Leetcode单排- 组合系列 (N39 N40 N77 N216)/","link":"","permalink":"https://weilans.github.io/2019/07/25/Leetcode单排- 组合系列 (N39 N40 N77 N216)/","excerpt":"","text":"39. Combination Sumhttps://leetcode.com/problems/combination-sum/ 给定一个目标值，以及一个数组，若从数组中取出若干个值能组成目标值的话即满足条件。这个题目有个重要的前提：数组中的值以及目标值都是正数。同时，题目还要求结果集要去重。如果只进行简单回溯，答案是会出现重复的，比如7的组成就有[2,2,3],[2,3,2],[3,2,2]，而答案只需其中之一。 大部分答案的做法是将数组排序后，定一个start值，后续递归只从下标为start的开始。但是实际上，不对数组进行排序答案依然是对的，原因在于，答案中避免重复真正要防止的是情况是：在某一轮递归中放入该值后，想隔一轮后递归轮次中又出现该值。比如这一轮递归中元素选择2，下一轮为3，再下一轮再继续选择2那就会出现重复。相同元素出现的递归轮次必须是靠在一起的。而只要做到这一点，你排序也好，不排也好，实际上对于获取正确答案都没有影响，只要满足数组中元素按一定顺序参与递归即可。 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (candidates == null || candidates.length == 0) &#123; return null; &#125; Arrays.sort(candidates); // 排序可有可无? List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(candidates, target, new ArrayList&lt;&gt;(), result, 0); return result;&#125;private void handle(int[] candidates, int curValue, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result, int start) &#123; if (curValue == 0) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; if (curValue &lt; 0) &#123; return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; curList.add(candidates[i]); handle(candidates, curValue - candidates[i], curList, result, i); curList.remove(curList.size() - 1); &#125;&#125; 那真的不用排序？当把不排序的代码丢进LeetCode判断时，答案虽是正确，但是时间排名较低。实际上，代码中一旦对数组进行排序，真正发挥排序作用是需要在for循环中加入这一段代码：if (candidates[i] &gt; curValue) { return; }，一旦判断当前下标值比目标curValue大，直接结束此轮判断，即进行一次剪枝，这次数据量非常大的时候能起到作用。按这种做法，时间空间排名都是top。 1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (candidates == null || candidates.length == 0) &#123; return null; &#125; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(candidates, target, new ArrayList&lt;&gt;(), result, 0); return result;&#125;private void handle(int[] candidates, int curValue, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result, int start) &#123; if (curValue == 0) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; // for 循环中既有判断，此处可省 //if (curValue &lt; 0) &#123; // return; // &#125; for (int i = start; i &lt; candidates.length; i++) &#123; // 真正发挥排序作用的是这个判断 if (candidates[i] &gt; curValue) &#123; return; // break 或 return &#125; curList.add(candidates[i]); handle(candidates, curValue - candidates[i], curList, result, i); curList.remove(curList.size() - 1); &#125;&#125; 40. Combination Sum IIhttps://leetcode.com/problems/combination-sum-ii/submissions/ 与上题不同的是每个数字在每个组合中只能使用一次。整个流程大致上不变，只是有一些小变动，比如递归中每次下标为 i + 1，非 i。另外还有一个变动是剪枝去重的判断条件，即同一层中如果有相同元素则略过。 这个判断条件第一次写的时候，写成了 i &gt; 0而非 i &gt; s ，这样写会造成示例1的答案中少了[1,1,6]，这是因为 i = 1的时候，下标1和下标0的元素比较了。所以在每一次递归中，i 应该要比起始下标 s 大。 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; if (candidates == null || candidates.length == 0) &#123; return null; &#125; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(candidates, target, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int[] candidates, int target, int s, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i = s; i &lt; candidates.length; i++) &#123; if (candidates[i] &gt; target) &#123; return; &#125; // 同一层中如果有相同元素则略过 if (i &gt; s &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; cur.add(candidates[i]); handle(candidates, target - candidates[i], i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 77. Combinationhttps://leetcode.com/problems/combinations/ 标准组合，从 n 里面取 k 个元素。要注意数组里没有相同数值，且数组间要避免重复，比如[1,4]和[4,1]就是重复的。所以只需将当前加入到 cur 中的值加1放入到下一层递归即可。 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (n &lt;= 0 || k &lt;= 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(n, k, 1, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int n, int k, int start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (cur.size() == k) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i = start; i &lt;= n; i++) &#123; cur.add(i); // 注意 i + 1 别写成 start + 1 handle(n, k, i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 216. Combination Sum IIIhttps://leetcode.com/problems/combination-sum-iii/submissions/ 同样没什么可讲的了，只是要注意可以进行适当的优化，比如if (k == curList.size())。 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(k, n, 1, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int k, int curTotal, int start, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (k == curList.size() &amp;&amp; curTotal == 0) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; // optimize if (k == curList.size()) &#123; return; &#125; for (int i = start; i &lt;= 9; i++) &#123; if (curTotal &lt; i) &#123; return; &#125; curList.add(i); handle(k,curTotal - i, i + 1, curList, result); curList.remove(curList.size() - 1); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"combination","slug":"combination","permalink":"https://weilans.github.io/tags/combination/"}]},{"title":"[Leetcode单排] 排列系列（N46 N47 N784）","slug":"Leetcode单排- 排列系列 (N46 N47 N784)","date":"2019-07-25T12:28:24.000Z","updated":"2019-07-28T14:04:23.976Z","comments":true,"path":"2019/07/25/Leetcode单排- 排列系列 (N46 N47 N784)/","link":"","permalink":"https://weilans.github.io/2019/07/25/Leetcode单排- 排列系列 (N46 N47 N784)/","excerpt":"","text":"晚上注册了新LeetCode账号，正式开始了LeetCode的从零单排。 其实有这个念头是因为近期工作中感觉没有学到新东西而有一种不安感。而且作为程序员，长期学习回顾算法也本是该有的觉悟。初步预期是每月50题，希望有个好的开始吧。 后续可能不单是LeetCode，比如同事推荐的HackerRank也很棒，支持的语言非常多，恰好最近在学Clojure，感觉里面的题稍偏难一些。 LeetCode刷题顺序初步先按照花花酱的题目分类来，现在还不习惯直接在网页上写，暂时先用IDE。万事开头难，先把第一个50题做完吧。 46. Permutationshttps://leetcode.com/problems/permutations/ 全排列算是比较基础的题了，想到的第一个词就是回溯。可以选择对数组中的元素进行重排序，也可以选择从数组中每次取一个值放到自己的临时List中，这也就是下面这两种方法。回溯需要注意的是如果操作的对象是可变的，在递归后需要把它变回来。当然如果在递归中传递的是新对象，则没这个必要了。 解法一123456789101112131415161718192021222324252627282930313233/** * 解法一：以数组中元素排序为准 */public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permute(nums, 0, result); return result;&#125;private void permute(int[] nums, int i, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (nums.length == i) &#123; List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); for (Integer integer : nums) &#123; cur.add(integer); &#125; result.add(cur); return; &#125; for (int j = i; j &lt; nums.length; j++) &#123; swap(nums, i, j); permute(nums, i + 1, result); swap(nums, i, j); &#125;&#125;private void swap(int[] nums, int m, int n) &#123; int temp = nums[m]; nums[m] = nums[n]; nums[n] = temp;&#125; 解法二12345678910111213141516171819202122232425262728293031/** * 解法二：以自定义List存放当前变量 */public List&lt;List&lt;Integer&gt;&gt; permute2(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permute2(nums, new ArrayList&lt;&gt;(), result); return result;&#125;/** * 查看是否包含某元素，除了直接使用contains判断外，很多人使用了boolean[] visited， * 递归前visited[i] = true，递归后还需visited[i] = false; * https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/ */private void permute2(int[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (nums.length == cur.size()) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i : nums) &#123; if (cur.contains(i)) &#123; continue; &#125; cur.add(i); permute2(nums, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 47. Permutations IIhttps://leetcode.com/problems/permutations-ii/ 若数组中有重复元素，在全排列基础上要去除重复的结果。这个题目的解法不容易立即想到的，需要在全排列的树上完成剪枝的操作，而难点就在于判断树的哪颗节点该剪。 首先需要对整个数组进行排列，这是判断剪枝的前提。如果数组下标为i的元素的值与i-1元素的值相同，并且i-1元素并没有被访问过，那么下标为i的元素才可以被剪枝。其实难点在于理解前一个元素并没有被访问过，可以通过画图进行理解。 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; // 排序 Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permute(nums, new ArrayList&lt;&gt;(), new boolean[nums.length], result); return result;&#125;/**注意剪枝规则*/private void permute(int[] nums, List&lt;Integer&gt; cur, boolean[] visit, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (cur.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (visit[i]) &#123; continue; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visit[i - 1]) &#123; continue; &#125; visit[i] = true; cur.add(nums[i]); permute(nums, cur, visit, result); cur.remove(cur.size() - 1); visit[i] = false; &#125;&#125; 784. Letter Case Permutationhttps://leetcode.com/problems/letter-case-permutation/ 即输入一个String，里面的字符可以是数字、小写字母、大写字母。小写和大写可以相互转变，需要给出所有的 String 结果。答案也不难想，使用递归来做。 123456789101112131415161718192021222324public List&lt;String&gt; letterCasePermutation(String S) &#123; if (S == null || S.length() == 0) &#123; return null; &#125; List&lt;String&gt; result = new ArrayList&lt;&gt;(); handle(S.toCharArray(), 0, result); return result;&#125;private void handle(char[] chars, int i, List&lt;String&gt; result) &#123; if (i == chars.length) &#123; result.add(new String(chars)); return; &#125; if (Character.isDigit(chars[i])) &#123; handle(chars, i + 1, result); &#125; else &#123; chars[i] = Character.toLowerCase(chars[i]); handle(chars, i + 1, result); chars[i] = Character.toUpperCase(chars[i]); handle(chars, i + 1, result); &#125;&#125; 实际上第一遍做的时候，我是使用了一个 String 变量保存了当前结果，结果是对的，只是内存耗的稍多一点。当然这个变量是可以省的，只是需要更改字符数组。 1234567891011121314151617private void handle(char[] chars, int i, String cur, List&lt;String&gt; result) &#123; if (i == chars.length) &#123; result.add(cur); return; &#125; if (Character.isDigit(chars[i])) &#123; handle(chars, i + 1, cur + chars[i], result); &#125; if (Character.isLowerCase(chars[i])) &#123; handle(chars, i + 1, cur + chars[i], result); handle(chars, i + 1, cur + Character.toUpperCase(chars[i]), result); &#125; if (Character.isUpperCase(chars[i])) &#123; handle(chars, i + 1, cur + chars[i], result); handle(chars, i + 1, cur + Character.toLowerCase(chars[i]), result); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"permutations","slug":"permutations","permalink":"https://weilans.github.io/tags/permutations/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"Clojure in Action: 概述、数据结构","slug":"Clojure-in-Action-概述、数据结构","date":"2019-07-25T11:30:34.000Z","updated":"2019-08-01T09:43:36.826Z","comments":true,"path":"2019/07/25/Clojure-in-Action-概述、数据结构/","link":"","permalink":"https://weilans.github.io/2019/07/25/Clojure-in-Action-概述、数据结构/","excerpt":"","text":"Clojure 概述 关键词：JVM、Lisp、动态类型、函数式语言、不可变数据结构、Code as data 1. Clojure 是 Lisp 的一个变种Clojure 对所有函数甚至类似运算符的一切都使用前缀表示法。 2. Clojure 以JVM为宿主Clojure 代码直接编译为字节码供JVM运行； Clojure 默认加载 java.lang包下的所有类； Clojure 直接使用 Java 类型和标准程序库，如 Clojure 的集合实现接口与 Java 集合接口相同，重用 Java 类型和接口可以使 Java 代码无缝使用 Clojure 类型； 使用点运算符作为与Java 互操作的基础：(. Math abs -3)、(. &quot;foo&quot; toUpperCase)，静态成员可以重写为(Math/abs -3)，实例方法调用也可以使用(.toUpperCase &quot;foo&quot;)，创建类的实例可以使用(new Integer &quot;42&quot;)或(Integer. &quot;42&quot;)； Clojure 的不可变数据结构使共享可变状态的问题变得毫无意义。即使需要变更状态，Clojure 也提供了var（变量）、atom（原子）、ref（引用）、agent（代理）的并发数据结构。 3. Clojure 是一种函数式编程语言函数是第一等公民，函数可以作为参数传递给其他参数，也可以作为输出值返回。FP设计的函数式纯粹的，具备引用透明性，只要函数输入相同就始终返回相同输出； FP一般默认不可变数据结构，将不可变结构作为语言的默认状态保证了函数不会修改传递给他们的参数。Clojure的不可变数据结构避免了高代价复制。当对一个不可变数据结构进行更改，结果则为一个全新的结构。Clojrue隐式使用结构化共享和其他技术，确保执行复制的次数最少、不可变数据结构的操作便捷且节约内存。比如在一颗树上添加新值，会在通往根节点的路径上创建一组新的节点和引用； Clojure鼓励使用纯函数式编程：不可变数据结构、高阶函数和代替强制循环的递归，甚至可以选择集合的惰性求值和及早求值。当然，为了适应不同场景，Clojure也提供了对共享状态变更的方法。 Clojure 基础前期准备1. Clojure REPL（读取 - 求值 - 打印循环）1234567891011(+ 1 2) ;=&gt; 3(def my-addition (fn [operand1 operand2] (+ operand1 operand2)));=&gt; #'user/my-addition(my-addition 1 2);=&gt; 3(my-addition 100 30);=&gt; 130(+ 1 2) \"Two forms on one line!\";=&gt; 3;=&gt; \"Two forms on one line!\" 第二个表达式定义了一个命名空间限定的全局符号user/my-addition 。前缀#&#39;表明这是一个 Clojure 变量，变量是一个可变容器，其中包含唯一值，本例中为加法函数。 函数中没有显示的 return 语句。从函数中返回的值总是函数中最后一个求值的表达式。 最后三行是按照形式运行，Clojure 持续读取，直到发现一个完整的形式，然后求值并打印，此后如果缓冲区里仍有字符，它读取另一个形式、求值并打印。 2. 特殊 REPL 变量变量*1，*2，*3，*e保存最后一个、倒数第二个、倒数第三个成功读取的形式和最后一个错误。每当新形式求值成功，该值会保存在*1，旧*1被移动到*2，旧*2被移动到*3。 3. 文档查找 doc：返回具体的函数描述，该 宏需要你了解具体的实体名称。 find-doc：接受一个字符串（可以是正则），模糊查询复合条件的函数或宏文档。该函数在不确定名称时很实用。 apropos：工作方式与find-doc类似，只打印匹配搜索模式的函数名称。 4. 其他细节 前缀表示法。没有任何运算符，数学运算符就是 Clojure 函数。 空格。Clojure 不需要逗号来区分列表元素，当实用逗号时，Clojure 会把它们当成逗号忽略。当然，特定场景如哈希映射，使用逗号有助于程序员理解。 注释。单行注释使用分号表示。多行注释可以使用comment宏，该宏会忽略传入的形式，返回 nil。此外，宏#_会告诉reader忽略下一个Clojure形式。 12[1 2 3 #_ 4 5];=&gt; [1 2 3 5] Clojure 大小写敏感。 Clojure 数据结构1. nil / 真值 / 价值Clojure 的 nil等价于 Java 的 null ，在 nil 上调用一个函数可能报空指针异常。 除了 false 和 nil 之外，其他值都被视为真值。 2. 字符 / 字符串Clojure 字符是 Java 字符， 使用反斜杠宏表示字符: 12(type \\a);=&gt; java.lang.Character Clojure 字符串是 Java 字符串，使用双引号表示。（单引号则是另一个读取器宏，来表示 Symbol） 12(type \"hello\");=&gt; java.lang.String Java String API 在 Clojure 中依然很有用。 3. 数值Clojure 使用的整数是64位整数（Long），浮点数是64位浮点数（Double）。当需要更大的范围时，可以使用BigInteger,BigDecimal。此外，还有一个不常见的数值类型：比例（ratio），比例在两个整数相除时创建。 123456789101112(type 2);=&gt; java.lang.Long(type 3.14);=&gt; java.lang.Double(type 1/3);=&gt; clojure.lang.Ratio(type true);=&gt; java.lang.Boolean(type 123N);=&gt; clojure.lang.BigInt(type 0.5M);=&gt; java.math.BigDecimal 当不同数值类型在同一个算术运算中混合使用时，具有高传染性的数值类型将其类型传染给结果(long &lt; bigint &lt; ratio &lt; bigdec &lt; double) 12345678(+ 1 1N);=&gt; 2N(+ 1 1N 1/2);=&gt; 5/2(+ 1 1N 1/2 0.5M);=&gt; 3.0M(+ 1 1N 1/2 0.5M 0.5);=&gt; 3.5 溢出（overflow）：在 Clojure 中可能产生溢出的算术运算只有整数加法、减法和乘法（整数相除时，如果超过范围则生成一个比例）。 溢出发生时 Clojure 会抛出 ArtithmeticException异常。如果希望结果提升为大整数，则应该使用：+&#39;，-&#39;，*&#39;，inc&#39;，dec&#39;。 1234(inc 9223372036854775807);ArithmeticException integer overflow clojure.lang.Numbers.throwIntOverflow (Numbers.java:1424)(inc' 9223372036854775807);=&gt; 9223372036854775808N 4. 符号 / 关键字符号是 Clojure 中的标识符，代表值的名称。符号本身只包含可选命名空间的名称，但当一个表达式求值时，它们被所代表的值取代。 在一个程序中，符号通常被解析为不是符号的其他内容，但是可以通过一个前导的单引号引用符号，将其当成一个值而非标识符。 当为一个符号加上引号，就将这个引号当成数据而不是代码来处理，在实践中一般不会这么做，因为有另一种特殊类型：关键词，关键词从不引用其他值，求值的结果总是他们本身。关键词的典型用法是作为哈希映射中的键和枚举值。 5. 列表 主要函数：list，list?，conj，peek，pop，count Clojure 列表是单链表。只能从列表前端添加或删除元素，这意味着多个不同列表可以共享相同尾部，使列表成为最简单的不可变数据结构。 1234567891011121314151617181920212223242526(list 1 2 3 4 5);=&gt; (1 2 3 4 5)(list? *1);=&gt; true(conj (list 1 2 3 4 5) 6);=&gt; (6 1 2 3 4 5)(conj (list 1 2 3) 4 5 6);=&gt; (6 5 4 1 2 3)(conj (conj (conj (list 1 2 3) 4) 5) 6) ;=&gt; (6 5 4 1 2 3); 可以将列表当成一个栈来对待(peek (list 1 2 3));=&gt; 1(pop (list 1 2 3));=&gt; (2 3)(peek (list)) ;=&gt; nil(pop (list)) ;IllegalStateException Can't pop empty list clojure.lang.PersistentList$EmptyList.pop (PersistentList.java:183)(count (list));=&gt; 0(count (list 1 2 3 4));=&gt; 4 列表的特殊性：Clojure 会假定列表中出现的第一个符号表示函数（或者宏）名称。Clojure 视图以处理所有列表的相同方式来处理表(1,2,3) ，第一个元素被视为函数，而这里的整数 1 并不是函数。若希望将其作为数据而非代码，解决方式就是加上引号：&#39;(1,2,3)。 实践中一般不会在 Clojure 代码中使用列表作为数据，而是使用向量类型。 6. 向量 主要函数：vector，get，nth，assoc, conj,peek，pop，count，subvec，函数本身 向量可以使用vector函数创建，也可以使用方括号表示法创建，可以快速随机访问向量中的元素。获取其中元素中的方法有get和nth，差别在于没有找到相应值时，nth 会报出错误，get 返回 nil。 12345678910111213(vector 10 20 30 40 50);=&gt; [10 20 30 40 50](def the-vector [10 20 30 40 50]);=&gt; #'user/the-vector(get the-vector 2);=&gt; 30(nth the-vector 2);=&gt; 30(get the-vector 10);=&gt; nil(nth the-vector 10);IndexOutOfBoundsException clojure.lang.PersistentVector.arrayFor (PersistentVector.java:107) nth Get Vector as fn Vector is nil nil nil Throw exception Index out of range Throw exception Nil Throw exception Support ‘not found’ param yes Yes no 修改向量的方法中最常见的是 assoc。 1234567(assoc the-vector 2 25) ; 可以变更现有索引 ;=&gt; [10 20 25 40 50](assoc the-vector 5 60) ; 可以添加到尾部 ;=&gt; [10 20 30 40 50 60](assoc the-vector 6 70) ; 但是不能超过尾部 ;IndexOutOfBoundsException clojure.lang.PersistentVector.assocN (PersistentVector.java:137) conj函数同样适用于向量，但在向量中新元素将会被添加到最后，因为那是向量中最快速的插入位置。 12(conj [1 2 3 4 5] 6);=&gt; [1 2 3 4 5 6] peek和pop也适用于向量，方法会查看向量的尾部，而不是列表的表头。 12345678(peek [1 2]);=&gt; 2(pop [1 2]);=&gt; [1](peek []) ;=&gt; nil(pop []) ;IllegalStateException Can't pop empty vector clojure.lang.PersistentVector.pop (PersistentVector.java:381) 向量本身也是取单一参数的函数。(但向量函数不接受第二个参数) 12(the-vector 3);=&gt; 40 subvec会返回向量的一个子向量 (subvec avec start end?)。若未指定end，则默认为向量的末尾。 1234(subvec [1 2 3 4 5] 3);-&gt; [4 5](subvec [1 2 3 4 5] 1 3);-&gt; [2 3] 7. 映射 主要函数：hash-map，sorted-map，assoc，dissoc，select-keys，merge， merge-with，assoc-in，get-in，update-in，keys，vals，contains?，get，函数本身 一个映射就是一个键值对序列。映射可以使用hash-map函数构建。依据键获取对应的值时除了使用get函数外，映射本身也是一个函数。 123456789101112131415161718(def the-map &#123;:a 1 :b 2 :c 3&#125;);=&gt; #'user/the-map(hash-map :a 1 :b 2 :c 3);=&gt; &#123;:a 1, :c 3, :b 2&#125;(the-map :b);=&gt; 2(:b the-map);=&gt; 2(:z the-map 26) ; 若未找到关键字则返回一个默认值;=&gt; 26(get the-map :z 26) ;=&gt; 26(the-map :z 26) ;=&gt; 26(sorted-map :c 3 :b 2 :a 1);=&gt; &#123;:a 1, :b 2, :c 3&#125; 映射字面量和 hash-map 函数不完全等价，Clojure 实际上有哈希映射(hash-map)以及数组映射(array-map)。数组映射以有序方式保存键和值，以扫描的方式进行查找。如果使用 assoc 函数将太多键关联到一个数组映射，那将会得到一个哈希映射（而哈希映射变得太小不会反悔一个数组映射）。透明地替换数据结构的实现是 Clojure 提高性能的常用技巧。 此外，sorted-map不会按照存放的顺序返回，它会根据键来进行排序。 映射的修改方法有assoc和dissoc等。assoc 返回新增了一个键值对的映射表， dissoc 返回移除了某些键的映射表。 select-keys返回一个映射表，仅保留了参数传入的那些键。merge可以合并映射表。如果多个映射表包含了同一个键，那么最右边的获胜。merge-with与 merge 很类似，除了当两个或以上的映射表中有相同的键时，你能指定一个你自己的函数，来决定如何合并这个键对应的值。 1234567891011121314(def updated-map (assoc the-map :d 4));=&gt; #'user/updated-mapupdated-map;=&gt; &#123;:d 4, :a 1, :b 2, :c 3&#125;(dissoc updated-map :a);=&gt; &#123;:b 2, :c 3, :d 4&#125;(select-keys updated-map [:a :b]);=&gt; &#123;:a 1, :b 2&#125;(merge updated-map &#123;:m 666, :n 777&#125;);=&gt; &#123;:a 1, :b 2, :c 3, :d 4, :m 666, :n 777&#125;(merge &#123;:a 1 :b 2&#125; &#123;:a 3 :c 4&#125;);=&gt; &#123;:a 3, :b 2, :c 4&#125;(merge-with + &#123;:a 1 :b 2&#125; &#123;:a 3 :c 4&#125;);=&gt; &#123;:a 4, :b 2, :c 4&#125; 关于嵌套映射的使用。想要更改嵌套映射中的值需要先进入想要的位置，创建一个更改后的映射，并用 assoc 将更改的信息关联到这个中间映射，并一路返回到根。Clojure提供三个简化嵌套更新的函数。 1234567891011121314151617(def users &#123;:kyle &#123;:date-joined \"2009-01-01\" :summary &#123;:average &#123;:monthly 1000 :yearly 12000&#125;&#125;&#125;&#125;); assoc-in 可以设置新值，若不存在任何嵌套映射，在创建并正确关联。(assoc-in users [:kyle :summary :average :monthly] 3000);=&gt; &#123;:kyle &#123;:date-joined \"2009-01-01\", :summary &#123;:average &#123;:monthly 3000,; :yearly 12000&#125;&#125;&#125;&#125;; get-in 可以嵌套读取值(get-in users [:kyle :summary :average :monthly]);=&gt; 1000; update-in 可以更新嵌套映射中的值，其不提供新值，而是提供一个函数(update-in users [:kyle :summary :average :monthly] + 500);=&gt; &#123;:kyle &#123;:date-joined \"2009-01-01\", :summary &#123;:average &#123;:monthly 1500,; :yearly 12000&#125;&#125;&#125;&#125; keys将所有的键作为序列返回，vals则将所有的值作为序列返回。 1234(keys &#123;:sundance \"spaniel\", :darwin \"beagle\"&#125;);-&gt; (:sundance :darwin)(vals &#123;:sundance \"spaniel\", :darwin \"beagle\"&#125;);-&gt; (\"spaniel\" \"beagle\") 无法确认究竟是键对应的值为 nil，还是这个键在映射表中根本就不存在。contains?函数就可以解决这个问题。（(:z the-map 26) 这种形式也可以做到。） 123(def score &#123;:stu nil :joey 100&#125;)(contains? score :stu);-&gt; true 8. Set 主要函数：conj，disj，contains?，set， hash-set，sorted-set，union，intersection，difference，select Clojure set 工作方式和数学中的 set 是一样的，是一种集合，其中的元素无序且唯一。Clojure 支持两种不同的 set：排序的(sorted-set)和不排序的(hash-set)。sorted-set 会依据自然顺序对值进行排序。 123456789101112131415161718#&#123;:a :b :c&#125;;=&gt; #&#123;:c :b :a&#125;(conj #&#123;:a :b :c&#125; :d);=&gt; #&#123;:c :b :d :a&#125;(conj #&#123;:a :b :c&#125; :a);=&gt; #&#123;:c :b :a&#125;(disj #&#123;:a :b :c&#125; :a);=&gt; #&#123;:c :b&#125;(contains? #&#123;1 2 3&#125; 3);=&gt; true; set函数期望其第一个参数是个容器。而hash-set则接受可变的参数列表。(set [:a :b :c]);=&gt; #&#123;:c :b :a&#125;(hash-set 1 2 3);=&gt; #&#123;1 3 2&#125;(sorted-set 2 3 1);=&gt; #&#123;1 2 3&#125; clojure.set 集合函数需先调用(use &#39;clojure.set)。 union返回的集合，包含了所有输入集合中的元素。intersection返回的集合，其所有元素都曾同时出现于多个输入集合中。difference 返回的集合，其所有元素都出现于第一个输入集合，但却未出现于第二个中。select返回所有元素都能与给定谓词相匹配的一个集合。 123456789101112(def languages #&#123;\"java\" \"c\" \"d\" \"clojure\"&#125;)(def beverages #&#123;\"java\" \"chai\" \"pop\"&#125;)(use 'clojure.set)(union languages beverages);=&gt; #&#123;\"java\" \"c\" \"d\" \"clojure\" \"chai\" \"pop\"&#125;(difference languages beverages);=&gt; #&#123;\"c\" \"d\" \"clojure\"&#125;(intersection languages beverages);=&gt; #&#123;\"java\"&#125;(select #(= 1 (.length %)) languages);=&gt; #&#123;\"c\" \"d\"&#125; 差集和并集除了是集合论的一部分，也是关系代数的一部分，下面介绍了投影、笛卡尔积、连接、重命名等方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657; 音乐作品集内存数据库示例(def compositions #&#123;&#123;:name \"The Art of the Fugue\" :composer \"J. S. Bach\"&#125; &#123;:name \"Musical Offering\" :composer \"J. S. Bach\"&#125; &#123;:name \"Requiem\" :composer \"Giuseppe Verdi\"&#125; &#123;:name \"Requiem\" :composer \"W. A. Mozart\"&#125;&#125;)(def composers #&#123;&#123;:composer \"J. S. Bach\" :country \"Germany\"&#125; &#123;:composer \"W. A. Mozart\" :country \"Austria\"&#125; &#123;:composer \"Giuseppe Verdi\" :country \"Italy\"&#125;&#125;)(def nations #&#123;&#123;:nation \"Germany\" :language \"German\"&#125; &#123;:nation \"Austria\" :language \"German\"&#125; &#123;:nation \"Italy\" :language \"Italian\"&#125;&#125;)(select #(= (:name %) \"Requiem\") compositions);=&gt; #&#123;&#123;:name \"Requiem\", :composer \"W. A. Mozart\"&#125;; &#123;:name \"Requiem\", :composer \"Giuseppe Verdi\"&#125;&#125;; project函数返回的那些映射表中，仅包含与参数匹配的键。 (project relation keys)(project compositions [:name]);=&gt; #&#123;&#123;:name \"Musical Offering\"&#125;; &#123;:name \"Requiem\"&#125;; &#123;:name \"The Art of the Fugue\"&#125;&#125;; 笛卡尔积(for [m compositions c composers] (concat m c)); join 集合连接(join compositions composers);=&gt; #&#123;&#123;:composer \"W. A. Mozart\", :country \"Austria\", :name \"Requiem\"&#125;; &#123;:composer \"J. S. Bach\", :country \"Germany\", :name \"Musical Offering\"&#125;; &#123;:composer \"Giuseppe Verdi\", :country \"Italy\", :name \"Requiem\"&#125;; &#123;:composer \"J. S. Bach\", :country \"Germany\", :name \"The Art of the Fugue\"&#125;&#125;;如果两个关系中的键名不匹配，你可以传入一个keymap，将relation-1中的键名映射到relation-2中对应的键。;例如，你可以将使用:country的composers，与使用:nation的nations相连接。(join composers nations &#123;:country :nation&#125;);=&gt; #&#123;&#123;:composer \"W. A. Mozart\", :country \"Austria\", :nation \"Austria\", :language \"German\"&#125;; &#123;:composer \"J. S. Bach\", :country \"Germany\", :nation \"Germany\", :language \"German\"&#125;; &#123;:composer \"Giuseppe Verdi\", :country \"Italy\", :nation \"Italy\", :language \"Italian\"&#125;&#125;; 示例: 所有创作了安魂曲的作曲家们，家乡都在哪些国家(project (join (select #(= (:name %) \"Requiem\") compositions) composers) [:country]);=&gt; #&#123;&#123;:country \"Italy\"&#125; &#123;:country \"Austria\"&#125;&#125;; rename 可以给键(数据库的列)重命名(rename compositions &#123;:name :title&#125;);=&gt;#&#123;&#123;:composer \"Giuseppe Verdi\", :title \"Requiem\"&#125;; &#123;:composer \"W. A. Mozart\", :title \"Requiem\"&#125;; &#123;:composer \"J. S. Bach\", :title \"The Art of the Fugue\"&#125;; &#123;:composer \"J. S. Bach\", :title \"Musical Offering\"&#125;&#125; 9. 序列序列是一个接口(ISeq)，Clojure 数据结构、函数和宏都普遍实现这个接口，序列抽象使所有数据结构的外表和行为像列表一样。 first返回序列的第一个元素，rest返回排除第一个元素的序列，但是对所有集合类型采取相同的方式。 cons会在序列的开始位置(即使是向量也一样)添加一个元素。 序列抽象通常是惰性的，尽管 first、rest、cons的结果打印出来像一个列表，但它们并没有进行创建列表的额外工作。序列抽象使一切都像操纵真正的列表一样，但是避免真正地创建任何新数据结构或者进行任何不必要的工作。 12345678910111213141516171819202122(first (list 1 2 3));=&gt; 1(rest (list 1 2 3));=&gt; (2 3)(first [1 2 3]);=&gt; 1(rest [1 2 3]);=&gt; (2 3)(first &#123;:a 1 :b 2&#125;) ; 不保证项的顺序;=&gt; [:b 2](rest &#123;:a 1 :b 2&#125;);=&gt; ([:a 1])(first []) ; 空集合调用first返回nil;=&gt; nil(rest []) ; 空集合调用 rest 返回空序列;=&gt; ()(cons 1 [2 3 4 5]);=&gt; (1 2 3 4 5)(list? (cons 1 (list 2 3)));=&gt; false 一切皆序列 主要函数：first，rest，cons，seq， next 可被视为序列的容器，被称为可序化的，可序化的容器包括：所有的Clojure容器、所有的Java容器、Java数组和字符串、正则表达式的匹配结果、目录结构、输入/输出流、XML树。 除了序列三大核心first、rest、cons，还有seq，seq 函数会返回一个序列，该序列源自任何一个可序化的其他容器。next 函数也会返回一个序列，该序列由除第一个元素以外的其他所有元素组成。(next aseq)等价于 (seq (rest aseq))。 12345678910(seq nil);=&gt; nil(seq ());=&gt; nil(rest ());=&gt; ()(next ());=&gt; nil(seq (rest ()));=&gt; nil conj &amp; intoconj 会向容器添加一个或是多个元素，into 则会把容器中的所有元素添加至另一个容器。这两个方法的返回值类型不是序列，而是容器类型。添加数据时，conj和into都会根据底层数据结构的特点选取最高效的插入点。 1234567891011;对于列表而言，conj和into会在其前端进行添加。(conj '(1 2 3) :a);=&gt; (:a 1 2 3)(into '(1 2 3) '(:a :b :c));=&gt; (:c :b :a 1 2 3);而对于向量，conj和into则会把元素添加至末尾。(conj [1 2 3] :a);=&gt; [1 2 3 :a](into [1 2 3] [:a :b :c]);=&gt; [1 2 3 :a :b :c] 创建序列 主要函数：range，repeat，take，iterate， cycle，interleave，interpose 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950;ranage会生成一个从start开始到end结束的序列，每次的增量为step。 (range start? end step?)(range 10);=&gt; (0 1 2 3 4 5 6 7 8 9)(range 10 20);=&gt; (10 11 12 13 14 15 16 17 18 19)(range 1 25 2);=&gt; (1 3 5 7 9 11 13 15 17 19 21 23);repeat函数会重复n次元素x。 (repeat n x)(repeat 5 1);=&gt; (1 1 1 1 1)(repeat 10 \"x\");=&gt; (\"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\");(iterate f x) iterate起始于值x，并持续地对每个值应用函数f，以计算下一个值，直至永远。;由于这是个无限序列，你需要另一个新函数 (take n sequence)。take会返回一个包含了容器中前n项元素的惰性序列。(take 10 (iterate inc 1));=&gt; (1 2 3 4 5 6 7 8 9 10);cycle函数接受一个容器，并无限的对其进行循环。 (cycle coll)(take 10 (cycle (range 3)));=&gt; (0 1 2 0 1 2 0 1 2 0);interleave函数接受多个容器作为参数，并产生一个新的容器，这个新容器会从每个参数容器中交错地提取元素，直至其中某个容器元素被耗尽。(defn whole-numbers [] (iterate inc 1))(interleave (whole-numbers) [\"A\" \"B\" \"C\" \"D\" \"E\"]);interpose函数，把输入序列中的每个元素用分隔符隔开，并作为新的序列返回。(interpose separator coll)(interpose \",\" [\"apples\" \"bananas\" \"grapes\"]);=&gt; (\"apples\" \",\" \"bananas\" \",\" \"grapes\");(apply f args* argseq)apply函数接受一个函数f、一些可选的args和一个序列argseq作为参数。之后会调用 f，并将args和argseq解开为一个参数列表传给f。(apply str (interpose \\, [\"apples\" \"bananas\" \"grapes\"]));=&gt; \"apples,bananas,grapes\";(join separator sequence)(use '[clojure.string :only (join)])(join \\, [\"apples\" \"bananas\" \"grapes\"]);=&gt; \"apples,bananas,grapes\";对应每种Clojure中的容器类型，都有一个可以接受任意数量参数的函数，用来创建该类型的容器。;hash-set与set与其工作方式稍有不同：set函数期望其第一个参数是个容器。而hash-set则接受可变的参数列表。(set [1 2 3]);=&gt; #&#123;1 3 2&#125;(hash-set 1 2 3);=&gt; #&#123;1 3 2&#125;;vector也有一个近亲vec，vec接受容器作为参数，而非可变的参数列表。(vec (range 3));=&gt; [0 1 2](vector 0 1 2);=&gt; [0 1 2] 过滤序列 主要函数：filter，take-while，drop-while，split-at， split-with 12345678910111213141516171819202122(defn whole-numbers [] (iterate inc 1));(filter pred coll) filter接受一个谓词和一个容器作为参数，并返回一个序列，这个序列的所有元素都经谓词判定为真。(take 10 (filter even? (whole-numbers)));=&gt; (2 4 6 8 10 12 14 16 18 20);使用take-while从序列中截取开头的一段，其每个元素都被谓词判定为真。 (take-while pred coll);字符串中逐个获取第一个元音字符之前的所有非元音字符(take-while (complement #&#123;\\a\\e\\i\\o\\u&#125;) \"the-quick-brown-fox\");=&gt; (\\t \\h);1、集合同时也可作为函数。所以你可以把#&#123;\\a\\e\\i\\o\\u&#125;读作“元音集”，或是“用于检测参数是否为元音的函数。”;2、complement 会反转另一个函数的行为。前例的那个反转函数用于检测参数是不是一个元音。;与take-while相对的是drop-while函数。drop-while 从序列的起始位置开始，逐个丢弃元素，直至谓词判定为真，然后返回序列剩余的部分。(drop-while (complement #&#123;\\a\\e\\i\\o\\u&#125;) \"the-quick-brown-fox\");=&gt; (\\e \\- \\q \\u \\i \\c \\k \\- \\b \\r \\o \\w \\n \\- \\f \\o \\x);split-at和split-with能把一个容器一分为二。(split-at index coll) (split-with pred coll);split-at接受一个索引作为参数，而split-with则接受一个谓词。(split-at 5 (range 10));=&gt;[(0 1 2 3 4) (5 6 7 8 9)](split-with #(&lt;= % 10) (range 0 20 2));=&gt;[(0 2 4 6 8 10) (12 14 16 18)] 序列谓词 主要函数：every?，some，not-every?，not-any? 1234567891011121314151617;every？要求其他谓词对序列中的每个元素都必须判定为真。(every? odd? [1 3 5]);=&gt; true(every? odd? [1 3 5 8]);=&gt; false;(some pred coll) 只要有一个元素被谓词判定为非假，some就会返回这个值，如果没有任何元素符合，则some返回nil。(some even? [1 2 3])-&gt; true(some even? [1 3 5])-&gt; nil;some 返回的是第一个符合项的值，而非 true。(some identity [nil false 1 nil 2]);=&gt; 1(not-every? even? (whole-numbers));=&gt; true(not-any? even? (whole-numbers));=&gt; false 序列转换 主要函数：map，reduce，sort，sort-by，for 123456789101112131415161718192021222324;映射函数map (map f coll) map接受一个源容器coll和一个函数f作为参数，并返回一个新的序列。(map #(format \"&lt;p&gt;%s&lt;/p&gt;\" %) [\"the\" \"quick\" \"brown\" \"fox\"]);=&gt; (\"&lt;p&gt;the&lt;/p&gt;\" \"&lt;p&gt;quick&lt;/p&gt;\" \"&lt;p&gt;brown&lt;/p&gt;\" \"&lt;p&gt;fox&lt;/p&gt;\");还可以传入多个容器给map。在这种情况下，f必须是一个多参函数。map会从每个容器分别取出一个值，作为参数来调用f，直到数量最少的那个容器被耗尽为止。(map #(format \"&lt;%s&gt;%s&lt;/%s&gt;\" %1 %2 %1) [\"h1\" \"h2\" \"h3\" \"h1\"] [\"the\" \"quick\" \"brown\" \"fox\"]);=&gt; (\"&lt;h1&gt;the&lt;/h1&gt;\" \"&lt;h2&gt;quick&lt;/h2&gt;\" \"&lt;h3&gt;brown&lt;/h3&gt;\" \"&lt;h1&gt;fox&lt;/h1&gt;\");归纳函数reduce (reduce f coll) reduce首先用coll的前两个元素作为参数来调用f，然后用得到的结果和第三个元素作为参数，继续调用f。(reduce + (range 1 11));=&gt; 55(reduce * (range 1 11));=&gt; 3628800;(sort comp? coll) (sort-by a-fn comp? coll) sort 会依据元素的自然顺序对容器进行排序，sort-by 则会对每个元素调用 a-fn，再依据得到的结果序列来进行排序。(sort [42 1 7 11]);=&gt; (1 7 11 42)(sort-by #(.toString %) [42 1 7 11]);=&gt;` (1 11 42 7);可以为sort或sort-by指定一个可选的比较函数comp。(sort &gt; [42 1 7 11]);=&gt; (42 11 7 1)(sort-by :grade &gt; [&#123;:grade 83&#125; &#123;:grade 90&#125; &#123;:grade 77&#125;]);=&gt; (&#123;:grade 90&#125; &#123;:grade 83&#125; &#123;:grade 77&#125;) Clojure把列表解析的概念泛化为了序列解析（sequence comprehension）。在Clojure中，是使用for宏来进行解析的。列表解析比诸如 map 和filter 这样的函数更加通用，而且，事实上它可以模拟之前的大多数过滤和转换函数。 1(for [binding-form coll-expr filter-expr? ...] expr) 123456789101112131415161718192021(defn whole-numbers [] (iterate inc 1))(for [word [\"the\" \"quick\" \"brown\" \"fox\"]] (format \"&lt;p&gt;%s&lt;/p&gt;\" word));=&gt; (\"&lt;p&gt;the&lt;/p&gt;\" \"&lt;p&gt;quick&lt;/p&gt;\" \"&lt;p&gt;brown&lt;/p&gt;\" \"&lt;p&gt;fox&lt;/p&gt;\");借助:when子句，解析也可以用来模拟filter函数。(take 10 (for [n (whole-numbers) :when (even? n)] n));=&gt; (2 4 6 8 10 12 14 16 18 20);只要:while字句的表达式保持为真，它就会继续进行求值。(for [n (whole-numbers) :while (even? n)] n);=&gt; ()(for [n (whole-numbers) :while (odd? n)] n);=&gt; (1)(for [n (whole-numbers) :while (&lt; n 5)] n);=&gt; (1 2 3 4);多个绑定表达式(for [file \"ABCDEFGH\" rank (range 1 9)] (format \"%c%d\" file rank));=&gt; (\"A1\" \"A2\" ...已省略... \"H7 \"\"H8\")(for [rank (range 1 9) file \"ABCDEFGH\"] (format \"%c%d\" file rank));=&gt; (\"A1\" \"B1\"... \"G8\" \"H8\") 序化正则表达式、文件系统、流 正则表达式： 12345678910(def matcher (re-matcher #\"\\d+\" \"abc12345def678\"));=&gt;#'user/matcher(re-find matcher);=&gt;\"12345\"(re-find matcher);=&gt; \"678\";; If you only want the first match, it is shorter to call re-find with the pattern and the string to search, rather than explicitly creating a matcher as above.(re-find #\"\\d+\" \"abc12345def\");=&gt;\"12345\" 使用正则更好的做法：(re-seq regexp string) re-seq 会把匹配结果暴露为一个不可变的序列。 12345678(re-seq #\"\\w+\" \"the quick brown fox\");=&gt; (\"the\" \"quick\" \"brown\" \"fox\")(sort (re-seq #\"\\w+\" \"the quick brown fox\"));=&gt; (\"brown\" \"fox\" \"quick\" \"the\")(drop 2 (re-seq #\"\\w+\" \"the quick brown fox\"));=&gt; (\"brown\" \"fox\")(map #(.toUpperCase %) (re-seq #\"\\w+\" \"the quick brown fox\"));=&gt; (\"THE\" \"QUICK\" \"BROWN\" \"FOX\") 文件系统： 12345678910(import '(java.io File)); 返回的是File数组，而非序列(.listFiles (File. \".\")); 返回序列(seq (.listFiles (File. \".\")) ); 想要获取name时可以使用map,一旦你决定使用诸如map这样的函数，再调用seq就会显得多余。序列库中的函数会替你调用seq。(map #(.getName %) (.listFiles (File. \".\")));遍历整个目录树。Clojure通过file-seq提供了一个深度优先的遍历方式(file-seq (File. \".\")) 流： 1234567(use '[clojure.java.io :only (reader)]); 统计文件多少行(with-open [rdr (reader \"src/examples/java.clj\")] (count (line-seq rdr))); 仅对非空行计数(with-open [rdr (reader \"src/examples/utils.clj\")] (count (filter #(re-find #\"\\S\" %) (line-seq rdr)))) 综合示例：获取clj代码行数 1234567891011(use '[clojure.java.io :only (reader)])(defn non-blank? [line] (if (re-find #\"\\S\" line) true false))(defn non-svn? [file] (not (.contains (.toString file) \".svn\")))(defn clojure-source? [file] (.endsWith (.toString file) \".clj\"))(defn clojure-loc [base-file] (reduce + (for [file (file-seq base-file) :when (and (clojure-source? file) (non-svn? file))] (with-open [rdr (reader file)] (count (filter non-blank? (line-seq rdr)))))))","categories":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/categories/clojure/"}],"tags":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/tags/clojure/"}]}]}