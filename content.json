{"meta":{"title":"HelloJohn","subtitle":"It’s been a long time.","description":null,"author":"Hello John","url":"https://weilans.github.io","root":"/"},"pages":[{"title":"[404]","date":"2019-07-21T14:56:15.913Z","updated":"2019-07-21T14:54:11.884Z","comments":true,"path":"404.html","permalink":"https://weilans.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-07-21T14:46:30.967Z","updated":"2019-07-21T14:46:30.967Z","comments":true,"path":"about/index.html","permalink":"https://weilans.github.io/about/index.html","excerpt":"","text":"你要忍，忍到春暖花开； 你要走，走到灯火通明； 你要看过世界辽阔，再评判是好是坏； 你要卯足劲变好，再旗鼓相当站在不敢想象的人身边； 你要变成想象中的样子，这件事，一步都不能让。"}],"posts":[{"title":"[Leetcode单排] Subsets (N78 N90)","slug":"Leetcode单排-Subsets-N78-N90","date":"2019-07-27T15:10:06.000Z","updated":"2019-07-27T15:31:20.290Z","comments":true,"path":"2019/07/27/Leetcode单排-Subsets-N78-N90/","link":"","permalink":"https://weilans.github.io/2019/07/27/Leetcode单排-Subsets-N78-N90/","excerpt":"","text":"78. Subsetshttps://leetcode.com/problems/subsets/ 这两道取子集的题目基本上也没什么好讲的，基本的回溯方法即可，处理方式同排列和组合系列。 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(nums, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int[] nums, int start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(cur)); for (int i = start; i &lt; nums.length; i++) &#123; cur.add(nums[i]); // 注意别写成 start + 1 handle(nums, i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 90. Subsets IIhttps://leetcode.com/problems/subsets-ii/ 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); handle(nums, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int[] nums, int start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(cur)); for (int i = start; i &lt; nums.length; i++) &#123; // 与 N40 中 for 循环里的 if 判断如出一辙 if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.add(nums[i]); handle(nums, i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/tags/leetcode/"},{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"[Leetcode单排] Letter Combinations of a Phone Number(N17)","slug":"Leetcode单排-Letter-Combinations-of-a-Phone-Number (N17)","date":"2019-07-26T06:59:38.000Z","updated":"2019-07-27T17:51:53.766Z","comments":true,"path":"2019/07/26/Leetcode单排-Letter-Combinations-of-a-Phone-Number (N17)/","link":"","permalink":"https://weilans.github.io/2019/07/26/Leetcode单排-Letter-Combinations-of-a-Phone-Number (N17)/","excerpt":"","text":"17.Letter Combinations of a Phone Numberhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/ 每个号码对应3或4个数字，输入一组号码，打印所有可能出现的排列。这道题很明显有BFS和DFS两类做法。 解法一当处理第n个数字时，实际上就是以n-1次的处理结果加上第n个数字对应的几个字符进行处理。 123456789101112131415161718192021/** * BFS 多层loop */public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; String digitArr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); result.add(\"\"); for (int i = 0; i &lt; digits.length(); i++) &#123; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); for (String str : result) &#123; for (char c : digitArr[digits.charAt(i) - '0'].toCharArray()) &#123; temp.add(str + c); &#125; &#125; result = temp; &#125; return result;&#125; 在答案中看到另一种BFS的做法，他是以一个Queue作为载体。这种做法很巧妙，但是在写 while 和 for 中条件时还是比较容易出错的。 123456789101112131415161718/** * BFS 使用queue，易错点在于while条件以及for中数组的获取 */public List&lt;String&gt; letterCombinations2(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; String digitArr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;(); result.add(\"\"); while (result.peek().length() != digits.length()) &#123; String peek = result.remove(); for (char c : digitArr[digits.charAt(peek.length()) - '0'].toCharArray()) &#123; result.add(peek + c); &#125; &#125; return result;&#125; 解法二在DFS中，表示当前结果的 String cur，在每次递归中都是一个新的String。一般在DFS的递归之后需要对表示当前结果的值进行回滚，而在这种场景下则不需要。 12345678910111213141516171819202122/** * DFS 递归 */public List&lt;String&gt; letterCombinations3(String digits) &#123; if (digits == null || digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; String digitArr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); dfs(digits, digitArr, 0, \"\", result); return result;&#125;private void dfs(String digits, String[] digitArr, int i, String cur, List&lt;String&gt; result) &#123; if (i == digits.length()) &#123; result.add(cur); return; &#125; for (char c : digitArr[digits.charAt(i) - '0'].toCharArray()) &#123; dfs(digits, digitArr, i + 1, cur + c, result); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/tags/leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"bfs","slug":"bfs","permalink":"https://weilans.github.io/tags/bfs/"}]},{"title":"[Leetcode单排] 组合系列 (N39 N40 N77 N216)","slug":"Leetcode单排- 组合系列 (N39 N40 N77 N216)","date":"2019-07-25T14:18:06.000Z","updated":"2019-07-27T17:53:22.088Z","comments":true,"path":"2019/07/25/Leetcode单排- 组合系列 (N39 N40 N77 N216)/","link":"","permalink":"https://weilans.github.io/2019/07/25/Leetcode单排- 组合系列 (N39 N40 N77 N216)/","excerpt":"","text":"39. Combination Sumhttps://leetcode.com/problems/combination-sum/ 给定一个目标值，以及一个数组，若从数组中取出若干个值能组成目标值的话即满足条件。这个题目有个重要的前提：数组中的值以及目标值都是正数。同时，题目还要求结果集要去重。如果只进行简单回溯，答案是会出现重复的，比如7的组成就有[2,2,3],[2,3,2],[3,2,2]，而答案只需其中之一。 大部分答案的做法是将数组排序后，定一个start值，后续递归只从下标为start的开始。但是实际上，不对数组进行排序答案依然是对的，原因在于，答案中避免重复真正要防止的是情况是：在某一轮递归中放入该值后，想隔一轮后递归轮次中又出现该值。比如这一轮递归中元素选择2，下一轮为3，再下一轮再继续选择2那就会出现重复。相同元素出现的递归轮次必须是靠在一起的。而只要做到这一点，你排序也好，不排也好，实际上对于获取正确答案都没有影响，只要满足数组中元素按一定顺序参与递归即可。 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (candidates == null || candidates.length == 0) &#123; return null; &#125; Arrays.sort(candidates); // 排序可有可无? List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(candidates, target, new ArrayList&lt;&gt;(), result, 0); return result;&#125;private void handle(int[] candidates, int curValue, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result, int start) &#123; if (curValue == 0) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; if (curValue &lt; 0) &#123; return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; curList.add(candidates[i]); handle(candidates, curValue - candidates[i], curList, result, i); curList.remove(curList.size() - 1); &#125;&#125; 那真的不用排序？当把不排序的代码丢进LeetCode判断时，答案虽是正确，但是时间排名较低。实际上，代码中一旦对数组进行排序，真正发挥排序作用是需要在for循环中加入这一段代码：if (candidates[i] &gt; curValue) { return; }，一旦判断当前下标值比目标curValue大，直接结束此轮判断，即进行一次剪枝，这次数据量非常大的时候能起到作用。按这种做法，时间空间排名都是top。 1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (candidates == null || candidates.length == 0) &#123; return null; &#125; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(candidates, target, new ArrayList&lt;&gt;(), result, 0); return result;&#125;private void handle(int[] candidates, int curValue, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result, int start) &#123; if (curValue == 0) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; // for 循环中既有判断，此处可省 //if (curValue &lt; 0) &#123; // return; // &#125; for (int i = start; i &lt; candidates.length; i++) &#123; // 真正发挥排序作用的是这个判断 if (candidates[i] &gt; curValue) &#123; return; // break 或 return &#125; curList.add(candidates[i]); handle(candidates, curValue - candidates[i], curList, result, i); curList.remove(curList.size() - 1); &#125;&#125; 40. Combination Sum IIhttps://leetcode.com/problems/combination-sum-ii/submissions/ 与上题不同的是每个数字在每个组合中只能使用一次。整个流程大致上不变，只是有一些小变动，比如递归中每次下标为 i + 1，非 i。另外还有一个变动是剪枝去重的判断条件，即同一层中如果有相同元素则略过。 这个判断条件第一次写的时候，写成了 i &gt; 0而非 i &gt; s ，这样写会造成示例1的答案中少了[1,1,6]，这是因为 i = 1的时候，下标1和下标0的元素比较了。所以在每一次递归中，i 应该要比起始下标 s 大。 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; if (candidates == null || candidates.length == 0) &#123; return null; &#125; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(candidates, target, 0, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int[] candidates, int target, int s, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i = s; i &lt; candidates.length; i++) &#123; if (candidates[i] &gt; target) &#123; return; &#125; // 同一层中如果有相同元素则略过 if (i &gt; s &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; cur.add(candidates[i]); handle(candidates, target - candidates[i], i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 77. Combinationhttps://leetcode.com/problems/combinations/ 标准组合，从 n 里面取 k 个元素。要注意数组里没有相同数值，且数组间要避免重复，比如[1,4]和[4,1]就是重复的。所以只需将当前加入到 cur 中的值加1放入到下一层递归即可。 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (n &lt;= 0 || k &lt;= 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(n, k, 1, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int n, int k, int start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (cur.size() == k) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i = start; i &lt;= n; i++) &#123; cur.add(i); // 注意 i + 1 别写成 start + 1 handle(n, k, i + 1, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 216. Combination Sum IIIhttps://leetcode.com/problems/combination-sum-iii/submissions/ 同样没什么可讲的了，只是要注意可以进行适当的优化，比如if (k == curList.size())。 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); handle(k, n, 1, new ArrayList&lt;&gt;(), result); return result;&#125;private void handle(int k, int curTotal, int start, List&lt;Integer&gt; curList, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (k == curList.size() &amp;&amp; curTotal == 0) &#123; result.add(new ArrayList&lt;&gt;(curList)); return; &#125; // optimize if (k == curList.size()) &#123; return; &#125; for (int i = start; i &lt;= 9; i++) &#123; if (curTotal &lt; i) &#123; return; &#125; curList.add(i); handle(k,curTotal - i, i + 1, curList, result); curList.remove(curList.size() - 1); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/tags/leetcode/"},{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"},{"name":"combination","slug":"combination","permalink":"https://weilans.github.io/tags/combination/"}]},{"title":"[Leetcode单排] 排列系列（N46 N47 N784）","slug":"Leetcode单排- 排列系列 (N46 N47 N784)","date":"2019-07-25T12:28:24.000Z","updated":"2019-07-27T17:52:36.753Z","comments":true,"path":"2019/07/25/Leetcode单排- 排列系列 (N46 N47 N784)/","link":"","permalink":"https://weilans.github.io/2019/07/25/Leetcode单排- 排列系列 (N46 N47 N784)/","excerpt":"","text":"晚上注册了新LeetCode账号，正式开始了LeetCode的从零单排。 其实有这个念头是因为近期工作中感觉没有学到新东西而有一种不安感。而且作为程序员，长期学习回顾算法也本是该有的觉悟。初步预期是每月50题，希望有个好的开始吧。 后续可能不单是LeetCode，比如同事推荐的HackerRank也很棒，支持的语言非常多，恰好最近在学Clojure，感觉里面的题稍偏难一些。 LeetCode刷题顺序初步先按照花花酱的题目分类来，现在还不习惯直接在网页上写，暂时先用IDE。万事开头难，先把第一个50题做完吧。 46. Permutationshttps://leetcode.com/problems/permutations/ 全排列算是比较基础的题了，想到的第一个词就是回溯。可以选择对数组中的元素进行重排序，也可以选择从数组中每次取一个值放到自己的临时List中，这也就是下面这两种方法。回溯需要注意的是如果操作的对象是可变的，在递归后需要把它变回来。当然如果在递归中传递的是新对象，则没这个必要了。 解法一123456789101112131415161718192021222324252627282930313233/** * 解法一：以数组中元素排序为准 */public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permute(nums, 0, result); return result;&#125;private void permute(int[] nums, int i, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (nums.length == i) &#123; List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); for (Integer integer : nums) &#123; cur.add(integer); &#125; result.add(cur); return; &#125; for (int j = i; j &lt; nums.length; j++) &#123; swap(nums, i, j); permute(nums, i + 1, result); swap(nums, i, j); &#125;&#125;private void swap(int[] nums, int m, int n) &#123; int temp = nums[m]; nums[m] = nums[n]; nums[n] = temp;&#125; 解法二12345678910111213141516171819202122232425262728293031/** * 解法二：以自定义List存放当前变量 */public List&lt;List&lt;Integer&gt;&gt; permute2(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permute2(nums, new ArrayList&lt;&gt;(), result); return result;&#125;/** * 查看是否包含某元素，除了直接使用contains判断外，很多人使用了boolean[] visited， * 递归前visited[i] = true，递归后还需visited[i] = false; * https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/ */private void permute2(int[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (nums.length == cur.size()) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i : nums) &#123; if (cur.contains(i)) &#123; continue; &#125; cur.add(i); permute2(nums, cur, result); cur.remove(cur.size() - 1); &#125;&#125; 47. Permutations IIhttps://leetcode.com/problems/permutations-ii/ 若数组中有重复元素，在全排列基础上要去除重复的结果。这个题目的解法不容易立即想到的，需要在全排列的树上完成剪枝的操作，而难点就在于判断树的哪颗节点该剪。 首先需要对整个数组进行排列，这是判断剪枝的前提。如果数组下标为i的元素的值与i-1元素的值相同，并且i-1元素并没有被访问过，那么下标为i的元素才可以被剪枝。其实难点在于理解前一个元素并没有被访问过，可以通过画图进行理解。 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; // 排序 Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permute(nums, new ArrayList&lt;&gt;(), new boolean[nums.length], result); return result;&#125;/**注意剪枝规则*/private void permute(int[] nums, List&lt;Integer&gt; cur, boolean[] visit, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (cur.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(cur)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (visit[i]) &#123; continue; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visit[i - 1]) &#123; continue; &#125; visit[i] = true; cur.add(nums[i]); permute(nums, cur, visit, result); cur.remove(cur.size() - 1); visit[i] = false; &#125;&#125; 784. Letter Case Permutationhttps://leetcode.com/problems/letter-case-permutation/ 即输入一个String，里面的字符可以是数字、小写字母、大写字母。小写和大写可以相互转变，需要给出所有的 String 结果。答案也不难想，使用递归来做。 123456789101112131415161718192021222324public List&lt;String&gt; letterCasePermutation(String S) &#123; if (S == null || S.length() == 0) &#123; return null; &#125; List&lt;String&gt; result = new ArrayList&lt;&gt;(); handle(S.toCharArray(), 0, result); return result;&#125;private void handle(char[] chars, int i, List&lt;String&gt; result) &#123; if (i == chars.length) &#123; result.add(new String(chars)); return; &#125; if (Character.isDigit(chars[i])) &#123; handle(chars, i + 1, result); &#125; else &#123; chars[i] = Character.toLowerCase(chars[i]); handle(chars, i + 1, result); chars[i] = Character.toUpperCase(chars[i]); handle(chars, i + 1, result); &#125;&#125; 实际上第一遍做的时候，我是使用了一个 String 变量保存了当前结果，结果是对的，只是内存耗的稍多一点。当然这个变量是可以省的，只是需要更改字符数组。 1234567891011121314151617private void handle(char[] chars, int i, String cur, List&lt;String&gt; result) &#123; if (i == chars.length) &#123; result.add(cur); return; &#125; if (Character.isDigit(chars[i])) &#123; handle(chars, i + 1, cur + chars[i], result); &#125; if (Character.isLowerCase(chars[i])) &#123; handle(chars, i + 1, cur + chars[i], result); handle(chars, i + 1, cur + Character.toUpperCase(chars[i]), result); &#125; if (Character.isUpperCase(chars[i])) &#123; handle(chars, i + 1, cur + chars[i], result); handle(chars, i + 1, cur + Character.toLowerCase(chars[i]), result); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://weilans.github.io/tags/leetcode/"},{"name":"backtracking","slug":"backtracking","permalink":"https://weilans.github.io/tags/backtracking/"},{"name":"permutations","slug":"permutations","permalink":"https://weilans.github.io/tags/permutations/"},{"name":"dfs","slug":"dfs","permalink":"https://weilans.github.io/tags/dfs/"},{"name":"search","slug":"search","permalink":"https://weilans.github.io/tags/search/"}]},{"title":"Clojure in Action: 概述、数据结构、函数","slug":"Clojure-in-Action-概述、数据结构、函数","date":"2019-07-25T11:30:34.000Z","updated":"2019-07-26T12:07:56.031Z","comments":true,"path":"2019/07/25/Clojure-in-Action-概述、数据结构、函数/","link":"","permalink":"https://weilans.github.io/2019/07/25/Clojure-in-Action-概述、数据结构、函数/","excerpt":"","text":"Clojure 概述 关键词：JVM、Lisp、动态类型、函数式语言、不可变数据结构、Code as data 1. Clojure 是 Lisp 的一个变种Clojure 对所有函数甚至类似运算符的一切都使用前缀表示法。 2. Clojure 以JVM为宿主Clojure 代码直接编译为字节码供JVM运行； Clojure 默认加载 java.lang包下的所有类； Clojure 直接使用 Java 类型和标准程序库，如 Clojure 的集合实现接口与 Java 集合接口相同，重用 Java 类型和接口可以使 Java 代码无缝使用 Clojure 类型； 使用点运算符作为与Java 互操作的基础：(. Math abs -3)、(. &quot;foo&quot; toUpperCase)，静态成员可以重写为(Math/abs -3)，实例方法调用也可以使用(.toUpperCase &quot;foo&quot;)，创建类的实例可以使用(new Integer &quot;42&quot;)或(Integer. &quot;42&quot;)； Clojure 的不可变数据结构使共享可变状态的问题变得毫无意义。即使需要变更状态，Clojure 也提供了var（变量）、atom（原子）、ref（引用）、agent（代理）的并发数据结构。 3. Clojure 是一种函数式编程语言函数是第一等公民，函数可以作为参数传递给其他参数，也可以作为输出值返回。FP设计的函数式纯粹的，具备引用透明性，只要函数输入相同就始终返回相同输出； FP一般默认不可变数据结构，将不可变结构作为语言的默认状态保证了函数不会修改传递给他们的参数。Clojure的不可变数据结构避免了高代价复制。当对一个不可变数据结构进行更改，结果则为一个全新的结构。Clojrue隐式使用结构化共享和其他技术，确保执行复制的次数最少、不可变数据结构的操作便捷且节约内存。比如在一颗树上添加新值，会在通往根节点的路径上创建一组新的节点和引用； Clojure鼓励使用纯函数式编程：不可变数据结构、高阶函数和代替强制循环的递归，甚至可以选择集合的惰性求值和及早求值。当然，为了适应不同场景，Clojure也提供了对共享状态变更的方法。 Clojure 基础前期准备1. Clojure REPL（读取 - 求值 - 打印循环）1234567891011(+ 1 2) ;=&gt; 3(def my-addition (fn [operand1 operand2] (+ operand1 operand2)));=&gt; #'user/my-addition(my-addition 1 2);=&gt; 3(my-addition 100 30);=&gt; 130(+ 1 2) \"Two forms on one line!\";=&gt; 3;=&gt; \"Two forms on one line!\" 第二个表达式定义了一个命名空间限定的全局符号user/my-addition 。前缀#&#39;表明这是一个 Clojure 变量，变量是一个可变容器，其中包含唯一值，本例中为加法函数。 函数中没有显示的 return 语句。从函数中返回的值总是函数中最后一个求值的表达式。 最后三行是按照形式运行，Clojure 持续读取，直到发现一个完整的形式，然后求值并打印，此后如果缓冲区里仍有字符，它读取另一个形式、求值并打印。 2. 特殊 REPL 变量变量*1，*2，*3，*e保存最后一个、倒数第二个、倒数第三个成功读取的形式和最后一个错误。每当新形式求值成功，该值会保存在*1，旧*1被移动到*2，旧*2被移动到*3。 3. 文档查找 doc：返回具体的函数描述，该 宏需要你了解具体的实体名称。 find-doc：接受一个字符串（可以是正则），模糊查询复合条件的函数或宏文档。该函数在不确定名称时很实用。 apropos：工作方式与find-doc类似，只打印匹配搜索模式的函数名称。 4. 其他细节 前缀表示法。没有任何运算符，数学运算符就是 Clojure 函数。 空格。Clojure 不需要逗号来区分列表元素，当实用逗号时，Clojure 会把它们当成逗号忽略。当然，特定场景如哈希映射，使用逗号有助于程序员理解。 注释。单行注释使用分号表示。多行注释可以使用comment宏，该宏会忽略传入的形式，返回 nil。此外，宏#_会告诉reader忽略下一个Clojure形式。 12[1 2 3 #_ 4 5];=&gt; [1 2 3 5] Clojure 大小写敏感。 Clojure 数据结构1. nil / 真值 / 价值Clojure 的 nil等价于 Java 的 null ，在 nil 上调用一个函数可能报空指针异常。 除了 false和nil之外，其他值都被视为真值。 2. 字符 / 字符串Clojure 字符是 Java 字符， 使用反斜杠宏表示字符: 12(type \\a);=&gt; java.lang.Character Clojure 字符串是 Java 字符串，使用双引号表示。（单引号则是另一个读取器宏，来表示 Symbol） 12(type \"hello\");=&gt; java.lang.String Java String API 在 Clojure 中依然很有用。 3. 数值Clojure 使用的整数是64位整数（Long），浮点数是64位浮点数（Double）。当需要更大的范围时，可以使用BigInteger,BigDecimal。此外，还有一个不常见的数值类型：比例（ratio），比例在两个整数相除时创建。 123456789101112(type 2);=&gt; java.lang.Long(type 3.14);=&gt; java.lang.Double(type 1/3);=&gt; clojure.lang.Ratio(type true);=&gt; java.lang.Boolean(type 123N);=&gt; clojure.lang.BigInt(type 0.5M);=&gt; java.math.BigDecimal 当不同数值类型在同一个算术运算中混合使用时，具有高传染性的数值类型将其类型传染给结果(long &lt; bigint &lt; ratio &lt; bigdec &lt; double) 12345678(+ 1 1N);=&gt; 2N(+ 1 1N 1/2);=&gt; 5/2(+ 1 1N 1/2 0.5M);=&gt; 3.0M(+ 1 1N 1/2 0.5M 0.5);=&gt; 3.5 溢出（overflow）：在 Clojure 中可能产生溢出的算术运算只有整数加法、减法和乘法（整数相除时，如果超过范围则生成一个比例）。 溢出发生时 Clojure 会抛出 ArtithmeticException异常。如果希望结果提升为大整数，则应该使用：+&#39;，-&#39;，*&#39;，inc&#39;，dec&#39;。 1234(inc 9223372036854775807);ArithmeticException integer overflow clojure.lang.Numbers.throwIntOverflow (Numbers.java:1424)(inc' 9223372036854775807);=&gt; 9223372036854775808N 4. 符号 / 关键字符号是 Clojure 中的标识符，代表值的名称。符号本身只包含可选命名空间的名称，但当一个表达式求值时，它们被所代表的值取代。 在一个程序中，符号通常被解析为不是符号的其他内容，但是可以通过一个前导的单引号引用符号，将其当成一个值而非标识符。 当为一个符号加上引号，就将这个引号当成数据而不是代码来处理，在实践中一般不会这么做，因为有另一种特殊类型：关键词，关键词从不引用其他值，求值的结果总是他们本身。关键词的典型用法是作为哈希映射中的键和枚举值。 5. 列表 主要方法：list，list?，conj，peek，pop，count Clojure 列表是单链表。只能从列表前端添加或删除元素，这意味着多个不同列表可以共享相同尾部，使列表成为最简单的不可变数据结构。 1234567891011121314151617181920212223242526(list 1 2 3 4 5);=&gt; (1 2 3 4 5)(list? *1);=&gt; true(conj (list 1 2 3 4 5) 6);=&gt; (6 1 2 3 4 5)(conj (list 1 2 3) 4 5 6);=&gt; (6 5 4 1 2 3)(conj (conj (conj (list 1 2 3) 4) 5) 6) ; Same as above.;=&gt; (6 5 4 1 2 3); 可以将列表当成一个栈来对待(peek (list 1 2 3));=&gt; 1(pop (list 1 2 3));=&gt; (2 3)(peek (list)) ; The \"head\" of an empty list is `nil`.;=&gt; nil(pop (list)) ; But the tail of an empty list is an exception!;IllegalStateException Can't pop empty list clojure.lang.PersistentList$EmptyList.pop (PersistentList.java:183)(count (list));=&gt; 0(count (list 1 2 3 4));=&gt; 4 Clojure 会假定列表中出现的第一个符号表示函数（或者宏）名称","categories":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/categories/clojure/"}],"tags":[{"name":"clojure","slug":"clojure","permalink":"https://weilans.github.io/tags/clojure/"}]}]}